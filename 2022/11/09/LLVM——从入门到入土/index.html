<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>LLVM——从入门到入土 | EPs1l0h's Castle</title><meta name="author" content="EPs1l0h"><meta name="copyright" content="EPs1l0h"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="感觉新生赛的 reverse 要被橄榄了，于是哥几个合计合计说要加个 OLLVM 混淆，感觉学不完了（悲 简介提到 LLVM，可能会有一些陌生，但是如果说到另一个编译框架，那可能是个写代码的应该都见过，那就是 GCC ， GCC的编译分为3个模块：前端，优化器和后端。  而 LLVM 其实和 GCC 差不多，也是分为3个模块  此外，我们一般用来编写 C&#x2F;C++&#x2F;OC 语言一般会用到 Clang&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="LLVM——从入门到入土">
<meta property="og:url" content="https://example.com/2022/11/09/LLVM%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/index.html">
<meta property="og:site_name" content="EPs1l0h&#39;s Castle">
<meta property="og:description" content="感觉新生赛的 reverse 要被橄榄了，于是哥几个合计合计说要加个 OLLVM 混淆，感觉学不完了（悲 简介提到 LLVM，可能会有一些陌生，但是如果说到另一个编译框架，那可能是个写代码的应该都见过，那就是 GCC ， GCC的编译分为3个模块：前端，优化器和后端。  而 LLVM 其实和 GCC 差不多，也是分为3个模块  此外，我们一般用来编写 C&#x2F;C++&#x2F;OC 语言一般会用到 Clang&#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover1.jpg?raw=true">
<meta property="article:published_time" content="2022-11-09T07:19:47.000Z">
<meta property="article:modified_time" content="2024-05-28T15:12:56.448Z">
<meta property="article:author" content="EPs1l0h">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover1.jpg?raw=true"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://example.com/2022/11/09/LLVM%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'LLVM——从入门到入土',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-28 23:12:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="source/css/aplayer_custom.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/writeup"><i class="fa-fw fas fa-folder-open"></i><span> writeup</span></a></li><li><a class="site-page child" href="/categories/notes"><i class="fa-fw fas fa-folder-open"></i><span> notes</span></a></li><li><a class="site-page child" href="/categories/jottings"><i class="fa-fw fas fa-folder-open"></i><span> jottings</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-link"></i><span> Link</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.cnblogs.com/Here-is-SG"><i class="fa-fw fas fa-link"></i><span> iPlayForSG</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://jameshoi.github.io/"><i class="fa-fw fas fa-link"></i><span> jameshoi</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.cnblogs.com/Only-xiaoxiao"><i class="fa-fw fas fa-link"></i><span> xiaoxiao</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.cnblogs.com/Clovershrub"><i class="fa-fw fas fa-link"></i><span> Clovershrub</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.gaoyucan.site/"><i class="fa-fw fas fa-link"></i><span> gaoyucan</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://demoyao100.github.io/"><i class="fa-fw fas fa-link"></i><span> moyao</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://lantern.cool/"><i class="fa-fw fas fa-link"></i><span> lantern</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> about</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover1.jpg?raw=true')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">EPs1l0h's Castle</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/writeup"><i class="fa-fw fas fa-folder-open"></i><span> writeup</span></a></li><li><a class="site-page child" href="/categories/notes"><i class="fa-fw fas fa-folder-open"></i><span> notes</span></a></li><li><a class="site-page child" href="/categories/jottings"><i class="fa-fw fas fa-folder-open"></i><span> jottings</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-link"></i><span> Link</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.cnblogs.com/Here-is-SG"><i class="fa-fw fas fa-link"></i><span> iPlayForSG</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://jameshoi.github.io/"><i class="fa-fw fas fa-link"></i><span> jameshoi</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.cnblogs.com/Only-xiaoxiao"><i class="fa-fw fas fa-link"></i><span> xiaoxiao</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://www.cnblogs.com/Clovershrub"><i class="fa-fw fas fa-link"></i><span> Clovershrub</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://blog.gaoyucan.site/"><i class="fa-fw fas fa-link"></i><span> gaoyucan</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://demoyao100.github.io/"><i class="fa-fw fas fa-link"></i><span> moyao</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://lantern.cool/"><i class="fa-fw fas fa-link"></i><span> lantern</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> about</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">LLVM——从入门到入土</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-09T07:19:47.000Z" title="发表于 2022-11-09 15:19:47">2022-11-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-28T15:12:56.448Z" title="更新于 2024-05-28 23:12:56">2024-05-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/notes/">notes</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="LLVM——从入门到入土"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>感觉新生赛的 reverse 要被橄榄了，于是哥几个合计合计说要加个 OLLVM 混淆，感觉学不完了（悲</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>提到 LLVM，可能会有一些陌生，但是如果说到另一个编译框架，那可能是个写代码的应该都见过，那就是 GCC ， GCC的编译分为3个模块：前端，优化器和后端。</p>
<p><img src="/2022/11/09/LLVM%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/1664376484373.png" alt="1664376484373"></p>
<p>而 LLVM 其实和 GCC 差不多，也是分为3个模块</p>
<p><img src="/2022/11/09/LLVM%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/1664376517263.png" alt="1664376517263"></p>
<p>此外，我们一般用来编写 C/C++/OC 语言一般会用到 Clang/LLVM 框架，Clang 的作用是把源文件生成中间代码 IR ，然后经由 LLVM 生成后端。</p>
<p> <img src="/2022/11/09/LLVM%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/1596887-20220909111605446-193291833.png" alt="img"> </p>
<p>单从编译原理上来说，GCC 和 LLVM 好像感觉差不多，但是 LLVM 作为一个新型的编译器框架，其相比于 GCC 的优势还是非常明显的。</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>LLVM 是高度模块化设计的，每一个模块都可以从 LLVM 项目中抽离出来单独使用，也就是说如果想开发一门新的语言，那么只需要把前端模块抽离出来进行修改；如果想应用一个新的平台，那么只需要把后端模块抽离出来进行修改，这相比于三个模块耦合在一起的GCC框架来说无疑是更加方便的。</p>
<h2 id="可拓展"><a href="#可拓展" class="headerlink" title="可拓展"></a>可拓展</h2><p>LLVM 为开发者提供了丰富的 API ，例如开发者可以通过 LLVM Pass 框架干预中间代码优化过程，并且配备了完善的文档。编写 LLVM Pass 也是我们基于 LLVM 实现代码混淆的一个很重要的手段。而传统 GCC 框架的拓展门槛很高，难度很大，很难对中间代码的生成进行优化。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h2><p>在 llvm-project 仓库的 <a target="_blank" rel="noopener" href="https://github.com/llvm/llvm-project/releases/tag/llvmorg-12.0.1">Releases界面</a> 下载 LLVM-Core 和 Clang 源代码：</p>
<p>llvm-12.0.1.src.tar.xz </p>
<p>clang-12.0.1.src.tar.xz </p>
<p>在 /home/Programs 文件夹内创建 llvm-project 文件夹，存放我们刚刚下载的源码压缩包并命名为 clang 和 llvm ，然后再新建一个 build 文件夹存放编译后的 LLVM 。</p>
<p><img src="/2022/11/09/LLVM%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/1664377553210.png" alt="1664377553210"></p>
<h2 id="编译LLVM项目"><a href="#编译LLVM项目" class="headerlink" title="编译LLVM项目"></a>编译LLVM项目</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -G <span class="string">&quot;Unix Makefiles&quot;</span> -DLLVM_ENABLE_PROJECTS=<span class="string">&quot;clang&quot;</span> \</span><br><span class="line">-DCMAKE_BUILD_TYPE=Release -DLLVM_TARGETS_TO_BUILD=<span class="string">&quot;X86&quot;</span> \</span><br><span class="line">-DBUILD_SHARED_LIBS=On ../llvm</span><br><span class="line">make</span><br><span class="line">make instal</span><br></pre></td></tr></table></figure>
<p>然后就是漫长的等待过程，差不多装了整整一上午，睡了个午觉醒来才装好，编译完成以后 build 文件夹里张这样。</p>
<p><img src="/2022/11/09/LLVM%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/1664377768476.png" alt="1664377768476"></p>
<h1 id="一次简单的LLVM-Pass编译（LLVM——Hello-World-）"><a href="#一次简单的LLVM-Pass编译（LLVM——Hello-World-）" class="headerlink" title="一次简单的LLVM Pass编译（LLVM——Hello World!）"></a>一次简单的LLVM Pass编译（LLVM——Hello World!）</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>编写一个 LLVM Pass，遍历程序中的所有函数，并输出 “Hello, ”+ 函数名，这里使用 CMake 对 LLVM Pass 进行编译，CMake其实可以理解为一个项目管理器，了解即可。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>LLVM 有多种类型的 Pass 可供选择，包括：ModulePass、FunctionPass、CallGraphPass、LoopPass等等。</p>
<p>这里选择 FunctionPass 类型。</p>
<h3 id="FunctionPass"><a href="#FunctionPass" class="headerlink" title="FunctionPass"></a>FunctionPass</h3><p>FunctionPass 以函数为单位进行处理。</p>
<p>FunctionPass 的子类必须实现 runOnFunction(Function &amp;F) 函数。</p>
<p>在 FunctionPass 运行时，会对程序中的每个函数执行runOnFunction 函数。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>利用 vscode 中的 Remote - ssh 插件远程连接 Linux 虚拟机，用Cmake进行项目创建，具体目录如下：</p>
<p><img src="/2022/11/09/LLVM%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/1664378567216.png" alt="1664378567216"></p>
<h3 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h3><p>存放编译后的 LLVM Pass</p>
<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><p><strong>TestProgram.cpp</strong>：一个简单的CTF逆向题，是我们编写 LLVM Pass 对其进行代码混淆的对象，源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt; cstdio &gt;</span> #<span class="keyword">include</span> <span class="string">&lt; cstring &gt;</span></span></span><br><span class="line"><span class="type">char</span> input[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> enc[<span class="number">100</span>] = <span class="string">&quot;\x86\x8a\x7d\x87\x93\x8b\x4d\x81\x80\x8a\</span></span><br><span class="line"><span class="string">\x43\x7f\x49\x49\x86\x71\x7f\x62\x53\x69\x28\x9d&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">encrypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> * dest, <span class="type">char</span> * src)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(src);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dest[i] = (src[i] + (<span class="number">32</span> - i)) ^ i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//flag&#123;s1mpl3_11vm_d3m0&#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please input your flag: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, input);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> dest[<span class="number">100</span>] = &#123;</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">encrypt</span>(dest, input);</span><br><span class="line">    <span class="type">bool</span> result = <span class="built_in">strlen</span>(input) == <span class="number">22</span> &amp;&amp; !<span class="built_in">memcmp</span>(dest, enc, <span class="number">22</span>);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Congratulations~\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sorry try again.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Transforms-include"><a href="#Transforms-include" class="headerlink" title="Transforms/include"></a>Transforms/include</h3><p> 存放整个 LLVM Pass 项目的头文件，暂时还没有用到 </p>
<h3 id="Transforms-src"><a href="#Transforms-src" class="headerlink" title="Transforms/src"></a>Transforms/src</h3><p>存放整个 LLVM Pass 项目的源代码， 也就是我们的 LLVM —— Hello World</p>
<p>源码如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm; <span class="comment">//llvm 命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="comment">// 我们自己的命名空间</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">HelloWorld</span> : <span class="keyword">public</span> FunctionPass <span class="comment">// 继承FunctionPass类</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="type">static</span> <span class="type">char</span> ID; <span class="comment">// 变量</span></span><br><span class="line">            <span class="built_in">HelloWorld</span>() : <span class="built_in">FunctionPass</span>(ID) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp; F)</span></span>; <span class="comment">// runOnFunction函数声明</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HelloWorld::runOnFunction</span><span class="params">(Function &amp; F)</span> <span class="comment">// 函数实现，输出 Hello: 函数名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">outs</span>() &lt;&lt; <span class="string">&quot;Hello: &quot;</span> &lt;&lt; F.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// outs获取输出流</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> HelloWorld::ID = <span class="number">0</span>; <span class="comment">// 初始化ID</span></span><br><span class="line"><span class="function"><span class="type">static</span> RegisterPass&lt;HelloWorld&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hlw&quot;</span>, <span class="string">&quot;LLVM Hello World&quot;</span>)</span></span>; <span class="comment">// 向llvm注册Pass并设定参数 hlw，输入该参数就表示用这个 HelloWorld.cpp Pass进行优化</span></span><br></pre></td></tr></table></figure>
<h3 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h3><p>整个 CMake 项目的配置文件，内容如下： </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参考官方文档：https://llvm.org/docs/CMake.html#developing-llvm-passes-out-ofsource</span></span><br><span class="line">project(OLLVM++)</span><br><span class="line">cmake_minimum_required(VERSION 3.13.4)</span><br><span class="line">find_package(LLVM REQUIRED CONFIG)</span><br><span class="line">list(APPEND CMAKE_MODULE_PATH <span class="string">&quot;<span class="variable">$&#123;LLVM_CMAKE_DIR&#125;</span>&quot;</span>)</span><br><span class="line">include(AddLLVM)</span><br><span class="line">include_directories(<span class="string">&quot;./include&quot;</span>) <span class="comment"># 包含 ./include 文件夹中的头文件</span></span><br><span class="line">separate_arguments(LLVM_DEFINITIONS_LIST NATIVE_COMMAND <span class="variable">$&#123;LLVM_DEFINITIONS&#125;</span>)</span><br><span class="line">add_definitions(<span class="variable">$&#123;LLVM_DEFINITIONS_LIST&#125;</span>)</span><br><span class="line">include_directories(<span class="variable">$&#123;LLVM_INCLUDE_DIRS&#125;</span>)</span><br><span class="line">add_llvm_library( LLVMObfuscator MODULE</span><br><span class="line">src/HelloWorld.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="test-sh"><a href="#test-sh" class="headerlink" title="test.sh"></a>test.sh</h3><p>编译 LLVM Pass 并对 Test 文件夹中的代码进行测试，内容如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./Build <span class="comment">#切换到Build文件夹</span></span><br><span class="line">cmake ../Transforms</span><br><span class="line">make <span class="comment">#对Transforms的项目进行编译</span></span><br><span class="line"><span class="built_in">cd</span> ../Test</span><br><span class="line">clang -S -emit-llvm TestProgram.cpp -o TestProgram.ll <span class="comment">#用clang将源代码编译为中间代码</span></span><br><span class="line">opt -load ../Build/LLVMObfuscator.so -hlw -S TestProgram.ll -o TestProgram_hlw.ll <span class="comment">#加载so文件并设定参数hlw，-S表示为文本格式的中间代码，输出优化后的IR中间代码</span></span><br><span class="line">clang TestProgram_hlw.ll -o TestProgram_hlw <span class="comment">#优化之后的中间代码编译为可执行文件</span></span><br><span class="line">./TestProgram_hlw <span class="comment">#运行</span></span><br></pre></td></tr></table></figure>
<p>编译完成后的目录如下：</p>
<p><img src="/2022/11/09/LLVM%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/1664380687580.png" alt="1664380687580"></p>
<p>输入 flag 后，出现 Congratulations 而且出现了 Hello：+函数名的输出，说明代码优化和编译成功。</p>
<p><img src="/2022/11/09/LLVM%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/1664380734605.png" alt="1664380734605"></p>
<h1 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h1><p>前面介绍过，LLVM框架中我们会先把前端代码给转化为一个叫 IR （中间代码的东西）， 我们写 LLVM PASS 所优化的对象就是 LLVM IR，因此可以看出，LLVM IR 是 LLVM 中很重要的一个东西，介绍它的文档就一个， <a target="_blank" rel="noopener" href="https://llvm.org/docs/LangRef.html">LLVM Language Reference Manual — LLVM 16.0.0git documentation</a> ，很全，但是纯英文（English👴可以看原版，像我这种就只能靠机翻）。</p>
<p><strong>那么 LLVM IR 到底是个啥呢？</strong></p>
<p>LLVM IR 是一门低级编程语言，语法类似于汇编，任何高级编程语言（如C++）都可以用 LLVM IR 表示，基于 LLVM IR 可以很方便地进行代码优化，在 LLVM 中，IR 有三种表示：</p>
<ul>
<li>第一种是可读的 IR，类似于汇编代码，但其实它介于高等语言和汇编之间，这种表示就是给人看的，磁盘文件后缀为<code>.ll</code></li>
<li>第二种是不可读的二进制IR，被称作位码（bit code），磁盘文件后缀为<code>.bc</code></li>
<li>第三种表示是一种内存格式，只保存在内存中，所以谈不上文件格式和文件后缀，这种格式是LLVM之所以编译快的一个原因，它不像gcc，每个阶段结束会生成一些中间过程文件，它编译的中间数据都是这第三种表示的IR。</li>
</ul>
<p>三种格式是完全等价的，我们可以在Clang/LLVM工具的参数中指定生成这些文件（默认不生成，对于非编译器开发人员来说，也没必要生成），可以通过<code>llvm-as</code>和<code>llvm-dis</code>来在前两种文件之间做转换。 </p>
<p><img src="/2022/11/09/LLVM%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/1665363814724.png" alt="1665363814724"></p>
<h2 id="IR-的结构"><a href="#IR-的结构" class="headerlink" title="IR 的结构"></a>IR 的结构</h2><p>一个源代码文件对应 LLVM IR 中的一个<strong>模块（Module）</strong>，下面一层是LLVM IR 中的函数表示源代码中的某个<strong>函数（Function）</strong>，再下面一层是函数中的若干<strong>基本块（Basic Block）</strong>，再下面是组成基本块的各种<strong>指令（Instruction）</strong>和标签。</p>
<p>Module 的头部信息包含程序的目标平台，如X86、ARM等等，和一些其他信息，全局符号包含全局变量、函数的定义与声明；Function 由若干基本块组成且有一个<strong>入口块</strong>；基本块在正常情况下，最后一条指令为跳转指令(<strong>br</strong> 或 <strong>switch</strong>)，或返回指令(<strong>retn</strong>)，也叫作<strong>终结指令</strong>(Terminator Instruction)。</p>
<p><img src="/2022/11/09/LLVM%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/1665363851592.png" alt="1665363851592"></p>
<h1 id="一些具体的IR代码介绍"><a href="#一些具体的IR代码介绍" class="headerlink" title="一些具体的IR代码介绍"></a>一些具体的IR代码介绍</h1><h2 id="终结指令（Terminate-Instruction）"><a href="#终结指令（Terminate-Instruction）" class="headerlink" title="终结指令（Terminate Instruction）"></a>终结指令（Terminate Instruction）</h2><h3 id="retn"><a href="#retn" class="headerlink" title="retn"></a>retn</h3><p>对应 return 语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret &lt;type&gt; &lt;value&gt;		; 返回特定类型返回值的return指令</span><br><span class="line">ret void			    ; 无返回值的return指令</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret i32 5					; 返回整数 5</span><br><span class="line">ret void 					; 无返回值</span><br><span class="line">ret &#123;i32, i8&#125; &#123;i32 4, i8 2&#125;   ; 返回一个结构体（少用）</span><br></pre></td></tr></table></figure>
<h3 id="br"><a href="#br" class="headerlink" title="br"></a>br</h3><p>BranchInst，对应 if 语句。无条件分支指令类似 jmp 指令，条件分支类似于 jnz， je 等条件跳转指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">br i1 &lt;code&gt;, label &lt;iftrue&gt;, label &lt;iffalse&gt;	  ; 条件分支</span><br><span class="line">br lable &lt;dest&gt; 								; 无条件分支</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Test:                               			; 条件跳转判等</span><br><span class="line">	%cond = icmp eq i32 %a, %b</span><br><span class="line">    br i1 %cond, label %IfEQ, label %IFUEQ</span><br><span class="line">IfEQ:</span><br><span class="line">	ret i32 1</span><br><span class="line">IfUEQ:</span><br><span class="line">	ret I32 0</span><br></pre></td></tr></table></figure>
<h3 id="icmp"><a href="#icmp" class="headerlink" title="icmp"></a>icmp</h3><p><strong>整数</strong>或者<strong>指针</strong>的比较指令，条件 cond 可以是 eq（相等），ne（不相等），ugt（无符号大于）等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = icmp &lt;cond&gt; &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt; ;比较op1和op2是否满足cond</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = icmp eq i32 4, 5             ; yields: result=false eq=equal</span><br><span class="line">&lt;result&gt; = icmp ne float* %X, %X	    ; yields: result=false ne=not equal</span><br><span class="line">&lt;result&gt; = icmp ult i16 4, 5		    ; yields: result=true ult=unsigned less than</span><br><span class="line">&lt;result&gt; = icmp sgt i16 4, 5		    ; yields: result=false sgt=signed greater than</span><br><span class="line">&lt;result&gt; = icmp ule i16 -4, 5		    ; yields: result=false ule=unsigned less or equal</span><br><span class="line">&lt;result&gt; = icmp sge i16 4, 5		    ; yields: result=false sge=signed greater or equal</span><br></pre></td></tr></table></figure>
<h3 id="fcmp"><a href="#fcmp" class="headerlink" title="fcmp"></a>fcmp</h3><p><strong>浮点数</strong>的比较指令，条件 cond 可以是 oeq（ordered and equal）, ueq（unordered or equal）, false（必定不成立）等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = fcmp &lt;cond&gt; &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; 比较两个浮点数是否满足条件cond</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = fcmp oeq float 4.0, 5.0  		; yields: result=false</span><br><span class="line">&lt;result&gt; = fcmp one float 4.0, 5.0			; yields: result=true</span><br><span class="line">&lt;result&gt; = fcmp olt float 4.0, 5.0 			; yields: result=true</span><br><span class="line">&lt;result&gt; = fcmp ueq double 1.0, 2.0			; yields: result=false</span><br></pre></td></tr></table></figure>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>对应 switch - case 指令，是 br 指令的升级版</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">switch &lt;intty&gt; &lt;value&gt;, label &lt;defaultdest&gt; [ &lt;intty&gt; &lt;val&gt;, label &lt;dest&gt; ... ]</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; 与条件跳转等效</span><br><span class="line">%Val = zext i1 %value to i32</span><br><span class="line">switch i32 %Val, label %truedest [ i32 0, label %falsedest ]</span><br><span class="line"></span><br><span class="line">; 与非条件跳转等效</span><br><span class="line">switch i32 0, label %dest [ ]</span><br><span class="line"></span><br><span class="line">; 拥有三个分支的条件跳转</span><br><span class="line">switch i32 %val, label %otherwise [ i32 0, label %onzero</span><br><span class="line">								 i32 1, label %onone</span><br><span class="line">								 i32 2, label %ontwo ]</span><br></pre></td></tr></table></figure>
<h2 id="二元运算指令-Binary-Operations"><a href="#二元运算指令-Binary-Operations" class="headerlink" title="二元运算指令 Binary Operations"></a>二元运算指令 Binary Operations</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p>对应 <strong>+</strong> 操作符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = add &lt;type&gt; &lt;op1&gt;, &lt;op2&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = add i32 4, %var   ; yields i32:result = 4 + %var</span><br></pre></td></tr></table></figure>
<h3 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h3><p>对应 <strong>-</strong> 操作符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = sub &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = sub i32 4, %var 			; yields i32:result = 4 - %var</span><br><span class="line">&lt;result&gt; = sub i32 0, %var 			; yields i32:result = -%var</span><br></pre></td></tr></table></figure>
<h3 id="sub-1"><a href="#sub-1" class="headerlink" title="sub"></a>sub</h3><p>对应 <strong>*</strong> 操作符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = mul &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = mul i32 4, %var 			; yields i32:result = 4 * %var</span><br></pre></td></tr></table></figure>
<h3 id="udiv"><a href="#udiv" class="headerlink" title="udiv"></a>udiv</h3><p>对应 <strong>/</strong> 操作符，无符号整数除法指令，如果存在 <strong>exact</strong> 关键字且 op1 不是 op2 的倍数，就会出现错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = udiv &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;		 ; yields ty:result</span><br><span class="line">&lt;result&gt; = udiv exact &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields ty:result</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = udiv i32 <span class="number">4</span>, %var 			; yields i32:result = <span class="number">4</span> / %var</span><br></pre></td></tr></table></figure>
<h3 id="sidv"><a href="#sidv" class="headerlink" title="sidv"></a>sidv</h3><p>对应 <strong>/</strong> 操作符，有符号整数除法指令，如果存在 <strong>exact</strong> 关键字且 op1 不是 op2 的倍数，就会出现错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = sdiv &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;		 ; yields ty:result</span><br><span class="line">&lt;result&gt; = sdiv exact &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields ty:result</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = sdiv i32 4, %var 			 ; yields i32:result = 4 / %var</span><br></pre></td></tr></table></figure>
<h3 id="urem"><a href="#urem" class="headerlink" title="urem"></a>urem</h3><p>对应 <strong>%</strong> 操作符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = urem &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;		 ; yields ty:result</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = urem i32 4, %var 			; yields i32:result = 4 % %var</span><br></pre></td></tr></table></figure>
<h3 id="srem"><a href="#srem" class="headerlink" title="srem"></a>srem</h3><p>对应 <strong>%</strong> 操作符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = srem &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;		 ; yields ty:result</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = srem i32 4, %var 			; yields i32:result = 4 % %var</span><br></pre></td></tr></table></figure>
<h2 id="按位二元运算-Bitwise-Binary-Operations"><a href="#按位二元运算-Bitwise-Binary-Operations" class="headerlink" title="按位二元运算 Bitwise Binary Operations"></a>按位二元运算 Bitwise Binary Operations</h2><h3 id="shl"><a href="#shl" class="headerlink" title="shl"></a>shl</h3><p>对应 <strong>&lt;&lt;</strong> 运算符，整数左移指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = shl &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = shl i32 4, %var		; yields i32: 4 &lt;&lt; %var</span><br><span class="line">&lt;result&gt; = shl i32 4, 2		    ; yields i32: 16</span><br><span class="line">&lt;result&gt; = shl i32 1, 10		; yields i32: 1024</span><br><span class="line">&lt;result&gt; = shl i32 1, 32		; undefined，因为爆了</span><br><span class="line">&lt;result&gt; = shl &lt;2 x i32&gt; &lt; i32 1, i32 1&gt;, &lt; i32 1, i32 2&gt;		; yields: result=&lt;2 x i32&gt; &lt;i32 2，i32 4&gt;</span><br></pre></td></tr></table></figure>
<h3 id="lshr"><a href="#lshr" class="headerlink" title="lshr"></a>lshr</h3><p>对应 <strong>&gt;&gt;</strong> 操作符，右移以后会在左侧补零。逻辑右移无论是有符号还是无符号，一律当无符号处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = lshr &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = lshr i324, 1				; yields i32:result = 2</span><br><span class="line">&lt;result&gt; = lshr i32 4, 2 			; yields i32:result = 1</span><br><span class="line">&lt;result&gt; = lshr i8 4, 3				; yields i8:result = 0</span><br><span class="line">&lt;result&gt; = lshr i8 -2, 1 		    ; yields i8:result = 0x7F，把-2右移一位得到0x7f</span><br><span class="line">&lt;result&gt; = lshr i32 1, 32 			; undefined</span><br><span class="line">&lt;result&gt; = lshr &lt;2 x i32&gt; &lt; i32 -2, i32 4&gt;, &lt;i32 1, i32 2&gt;   ; yields: result=&lt;2 x i32&gt;&lt;i32 0x7FFFFFF, i32 1&gt;</span><br></pre></td></tr></table></figure>
<h3 id="ashr"><a href="#ashr" class="headerlink" title="ashr"></a>ashr</h3><p>整数算术右移指令，右移以后会在左侧补上符号位。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = ashr &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = ashr i324, 1				; yields i32:result = 2</span><br><span class="line">&lt;result&gt; = ashr i32 4, 2 			; yields i32:result = 1</span><br><span class="line">&lt;result&gt; = ashr i8 4, 3				; yields i8:result = 0</span><br><span class="line">&lt;result&gt; = ashr i8 -2, 1 		    ; yields i8:result = -1，出现差别</span><br><span class="line">&lt;result&gt; = ashr i32 1, 32 			; undefined</span><br><span class="line">&lt;result&gt; = ashr &lt;2 x i32&gt; &lt; i32 -2, i32 4&gt;, &lt;i32 1, i32 2&gt;   ; yields: result=&lt;2 x i32&gt;&lt;i32 -1, i32 0&gt;</span><br></pre></td></tr></table></figure>
<h3 id="and"><a href="#and" class="headerlink" title="and"></a>and</h3><p>对应 <strong>&amp;</strong> 运算符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = and &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = and i32 4, %var 			; yields i32:result = 4 &amp; %var</span><br><span class="line">&lt;result&gt; = and i32 15, 40 			; yields i32:result = 8</span><br><span class="line">&lt;result&gt; = and i32 4, 8 			; yields i32:result = 0</span><br></pre></td></tr></table></figure>
<h3 id="or"><a href="#or" class="headerlink" title="or"></a>or</h3><p>对应 <strong>|</strong> 运算符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = or &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = or i32 4, %var 			; yields i32:result = 4 | %var</span><br><span class="line">&lt;result&gt; = or i32 15, 40 			; yields i32:result = 47</span><br><span class="line">&lt;result&gt; = or i32 4, 8 				; yields i32:result = 12</span><br></pre></td></tr></table></figure>
<h3 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = xor &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = xor i32 4, %var 			; yields i32:result = 4 ^ %var</span><br><span class="line">&lt;result&gt; = xor i32 15, 40 			; yields i32:result = 39</span><br><span class="line">&lt;result&gt; = xor i32 4, 8 			; yields i32:result = 12</span><br><span class="line">&lt;result&gt; = xor i32 %V, -1 			; yields i32:result = ~%V</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="内存访问和寻址操作-Memory-Access-and-Addressing-Operations"><a href="#内存访问和寻址操作-Memory-Access-and-Addressing-Operations" class="headerlink" title="内存访问和寻址操作 Memory Access and Addressing Operations"></a>内存访问和寻址操作 Memory Access and Addressing Operations</h2><h3 id="静态单赋值-Static-Single-Assignment"><a href="#静态单赋值-Static-Single-Assignment" class="headerlink" title="静态单赋值 Static Single Assignment"></a>静态单赋值 Static Single Assignment</h3><p>SSA 是 IR 的一种属性，也就是说：<strong>在程序中一个变量仅能有一条赋值语句</strong></p>
<p>下图这个过程中，由于变量 x, y, z 都被赋值了两次，因此不满足SSA</p>
<p><img src="/2022/11/09/LLVM%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/1665376335940.png" alt="1665376335940"></p>
<p>怎样修改才能让它满足 SSA 呢？</p>
<p><img src="/2022/11/09/LLVM%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/1665376402684.png" alt="1665376402684"></p>
<p>我们把它改成这样就可以了，下面再举一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello, %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个很简单的 for 循环语句，但是有个问题就是变量 i 被赋值了多次，这是不满足 SSA 原则的，那么怎样修改才能让它满足 SSA 呢？</p>
<p>第一种解决方案：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *i = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (*i = <span class="number">0</span>; *i &lt; <span class="number">100</span>; ++(*i))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello, %d\n&quot;</span>, *i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把 <strong>i</strong> 由 int 型变量变成 int 型指针，我们在操作的时候通过指针来操作内存，这样 i 就只被赋值了一次，而后面的操作也没有对变量 i 进行操作，因此这是符合 SSA 的，这种方法也是 LLVM IR 所采用的。</p>
<h3 id="alloca"><a href="#alloca" class="headerlink" title="alloca"></a>alloca</h3><p>内存分配指令，在<strong>栈中</strong>分配一段空间并获取指针（C中的 malloc 是在堆中分配内存）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = alloca &lt;type&gt; [, &lt;ty&gt; &lt;NumElements&gt;] [, align &lt;alignment&gt;]		;分配sizeof(type)*NumElements字节的内存，分配的地址与alignment对齐</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%ptr = alloca i32					  ;分配4字节的内存并返回i32类型的指针</span><br><span class="line">%ptr = alloca i32, i32 4			   ;分配4*4字节的内存并返回i32类型的指针</span><br><span class="line">%ptr = alloca i32, i32 4, align 1024    ;分配4*4字节的内存并返回i32类型的指针，分配的地址与1024对齐</span><br><span class="line">%ptr = alloca i32, align 1024	  	   ;分配4字节的内存并返回i32类型的指针，分配的地址与1024对齐</span><br></pre></td></tr></table></figure>
<p><type>为数据类型，比如是i32的数据，<NumElements>为数据的数量。align是对齐的意思，也就是说分配的内存空间会与alignment的对齐。例如alignment是1024，那么分配的地址空间一定是1024的倍数。 </NumElements></type></p>
<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>内存存储指令，即向内存中存储数据，类似指针赋值操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store &lt;ty&gt; &lt;value&gt;, &lt;ty&gt;* &lt;pointer&gt;  ; 向特定类型指针指向的内存存储相同类型的数据</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%ptr = alloca i32</span><br><span class="line">store i32 3, i32* %ptr</span><br></pre></td></tr></table></figure>
<p>store 要和 alloca 搭配使用，先分配空间，再对空间进行赋值。</p>
<h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><p>内存读取指令，可以从指针指向的内存中读取数据，类似指针引用操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load &lt;ty&gt; &lt;value&gt;, &lt;ty&gt;* &lt;pointer&gt;  ; 从特定类型指针指向的内存中读取特定类型的数据</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%ptr = alloca i32			; yields i32* :ptr</span><br><span class="line">store i32 3, i32* ptr		; yields void</span><br><span class="line">%val = load i32, i32* %ptr	; yields i32:val = i32 3</span><br></pre></td></tr></table></figure>
<h2 id="类型转换操作-Conversion-Operations"><a href="#类型转换操作-Conversion-Operations" class="headerlink" title="类型转换操作  Conversion Operations"></a>类型转换操作  Conversion Operations</h2><h3 id="trunc…to"><a href="#trunc…to" class="headerlink" title="trunc…to"></a>trunc…to</h3><p>截断指令，即大类型向小类型的强制转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = trunc &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;  ; 将ty类型的变量截断为ty2类型的变量</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%X = trunc i32 257 to i8 						; yields i8:1</span><br><span class="line">%Y = trunc i32 123 to i1 						; yields i1:true</span><br><span class="line">%Z = trunc i32 122 to i1						; yields i1:false</span><br><span class="line">%W = trunc &lt;2 x i16&gt; &lt;i16 8, i16 7&gt; to &lt;2 x i8&gt; ; yields &lt;i8 8, i8 7&gt;</span><br></pre></td></tr></table></figure>
<h3 id="zext…to"><a href="#zext…to" class="headerlink" title="zext…to"></a>zext…to</h3><p> 零拓展（Zero Extend）指令，将一种类型的变量拓展为另一种类型的变量，高位补0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = zext &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;  ; 将ty类型的变量拓展为ty2类型的变量</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%X = zext i32 257 to i64 						; yields i64:257</span><br><span class="line">%Y = zext i1 true to i32 						; yields i32:1</span><br><span class="line">%Z = zext &lt;2 x i16&gt; &lt;i16 8, i16 7&gt; to &lt;2 x i32&gt; ; yields &lt;i32 8, i32 7&gt;</span><br></pre></td></tr></table></figure>
<h3 id="sext…to"><a href="#sext…to" class="headerlink" title="sext…to"></a>sext…to</h3><p> 符号位拓展（Sign Extend）指令，通过复制符号位（最高位）将一种类型的变量拓展为另一种类型的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = sext &lt;ty&gt; &lt;value&gt; to &lt;ty2&gt;  ; 将ty类型的变量拓展为ty2类型的变量</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%X = sext i8 -1 to i16 							; yields i16:-1</span><br><span class="line">%Y = sext i1 true to i32 						; yields i32:-1</span><br><span class="line">%Z = sext &lt;2 x i16&gt; &lt;i16 8, i16 7&gt; to &lt;2 x i32&gt; ; yields &lt;i32 8, i32 7&gt;</span><br></pre></td></tr></table></figure>
<h2 id="其他操作-Other-Operations"><a href="#其他操作-Other-Operations" class="headerlink" title="其他操作 Other Operations"></a>其他操作 Other Operations</h2><h3 id="phi-指令"><a href="#phi-指令" class="headerlink" title="phi 指令"></a>phi 指令</h3><p>如下图，从两个条件分支跳转过来的 y1 和 y2 是不一样的，那么我们应该如何才能知道应该用 y1 还是 y2 呢？</p>
<p><img src="/2022/11/09/LLVM%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/1665403300737.png" alt="1665403300737"></p>
<p>这时候要引入 PHI 指令，$\Phi$函数的运算结果由前驱块而定，如果我们的程序从左边执行下来，那么φ的运算结果就是 y1，右边执行下来结果就是 y2。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = phi &lt;ty&gt; [&lt;val0&gt;, &lt;label0&gt;], ... ;如果前驱块为label0，则result=val0 ...</span><br></pre></td></tr></table></figure>
<p>首先得定义 phi 运算的结果的类型 ty ，然后定义了一系列的值以及对应的标签。如果 phi 指令对应的前驱块是 label0，那 phi 的运算结果就是 val0。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Loop: ; Infinite loop that counts from 0 on up. . .</span><br><span class="line">	%indvar = phi i32 [ 0, %LoopHeader ]， [ %nextindvar, %Loop ]</span><br><span class="line">	%nextindvar = add i32 %indvar, 1</span><br><span class="line">	br label %Loop</span><br></pre></td></tr></table></figure>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>类似于三元运算符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = select i1 &lt;cond&gt;, &lt;ty&gt; &lt;val1&gt;, &lt;ty&gt; &lt;val2&gt; ;如果条件cond 成立，result=val1，否则result=val2</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%X = select i1 true, i8 17, i8 42; yields i8:17</span><br></pre></td></tr></table></figure>
<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>调用某个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;result&gt; = call &lt;ty&gt;|&lt;fnty&gt; &lt;fnptrval&gt;(&lt;function args&gt;)	;调用函数</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%retval = call i32 @test( i32 %argc) 			; 调用test函数，参数为i32类型，返回值为i32类型</span><br><span class="line">call i32 (i8*, ...)* @printf( i8* %msg, i32 12，i8 42) ; 调用printf函数，参数可变</span><br></pre></td></tr></table></figure>
<h1 id="第一个-LLVM-Pass-——-LLVM-Hello-World"><a href="#第一个-LLVM-Pass-——-LLVM-Hello-World" class="headerlink" title="第一个 LLVM Pass —— LLVM Hello World"></a>第一个 LLVM Pass —— LLVM Hello World</h1><p>相当于一个 LLVM Pass 的模板，这里只实现了一个简单的操作：在 <code>runOnFunction</code> 函数中输出 Hello + 函数名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm; <span class="comment">//llvm 命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="comment">// 我们自己的命名空间</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">HelloWorld</span> : <span class="keyword">public</span> FunctionPass <span class="comment">// 继承FunctionPass类</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="type">static</span> <span class="type">char</span> ID; <span class="comment">// 变量</span></span><br><span class="line">            <span class="built_in">HelloWorld</span>() : <span class="built_in">FunctionPass</span>(ID) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp; F)</span></span>; <span class="comment">// runOnFunction函数声明</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HelloWorld::runOnFunction</span><span class="params">(Function &amp; F)</span> <span class="comment">// 函数实现，输出 Hello: 函数名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">outs</span>() &lt;&lt; <span class="string">&quot;Hello: &quot;</span> &lt;&lt; F.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;   <span class="comment">// outs获取输出流</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> HelloWorld::ID = <span class="number">0</span>; <span class="comment">// 初始化ID</span></span><br><span class="line"><span class="function"><span class="type">static</span> RegisterPass&lt;HelloWorld&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;hlw&quot;</span>, <span class="string">&quot;LLVM Hello World&quot;</span>)</span></span>; <span class="comment">// 向llvm注册Pass并设定参数 hlw，输入该参数就表示用这个 HelloWorld.cpp Pass进行优化</span></span><br></pre></td></tr></table></figure>
<p>我们把这个项目编译到 LLVM 中并优化 TestProgram 的中间代码</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ./Build <span class="comment">#切换到Build文件夹</span></span><br><span class="line">cmake ../Transforms</span><br><span class="line">make <span class="comment">#对Transforms的项目进行编译</span></span><br><span class="line"><span class="built_in">cd</span> ../Test</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;---------------------Hello World-----------------------------&quot;</span></span><br><span class="line">clang -S -emit-llvm TestProgram.cpp -o IR/TestProgram.ll <span class="comment">#用clang将源代码编译为中间代码</span></span><br><span class="line">opt -load ../Build/LLVMObfuscator.so -hlw -S IR/TestProgram.ll -o IR/TestProgram_hlw.ll <span class="comment">#加载so文件并设定参数hlw，-S表示为文本格式的中间代码，输出优化后的IR中间代码</span></span><br><span class="line">clang IR/TestProgram_hlw.ll -o Bin/TestProgram_hlw <span class="comment">#优化之后的中间代码编译为可执行文件</span></span><br><span class="line">./Bin/TestProgram_hlw flag&#123;s1mpl3_11vm_d3m0&#125; <span class="comment">#运行</span></span><br></pre></td></tr></table></figure>
<p>后面的 LLVM Pass 的编写也将基于这个模板来实现。</p>
<h1 id="基本块分割——Split-Basic-Block"><a href="#基本块分割——Split-Basic-Block" class="headerlink" title="基本块分割——Split Basic Block"></a>基本块分割——Split Basic Block</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>把每个没有 PHI 指令的基本块分割为若干块，我们对每个基本块的每一条指令进行遍历，在我们需要分割的地方调用 <code>splitBasicBlock</code>方法把当前指令和其之前的基本块分开。</p>
<p>为什么要避开 PHI 指令呢？</p>
<p>因为 PHI 指令的结果由前驱决定， 而基本块分割会改变其前驱，因此我们选择跳过有 PHI 指令的基本块。</p>
<p>在执行分割函数之前，我们需要先用一个 vector 把原先的基本块给存起来。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/Instructions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;SplitBasicBlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Support/CommandLine.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm; <span class="comment">//llvm 命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选的参数，指定一个基本块会被分裂成几个基本块，默认值为 2</span></span><br><span class="line"><span class="function"><span class="type">static</span> cl::opt&lt;<span class="type">int</span>&gt; <span class="title">splitNum</span><span class="params">(<span class="string">&quot;split_num&quot;</span>, cl::init(<span class="number">2</span>), cl::desc(<span class="string">&quot;Split&lt;split_num&gt; time(s) each BB&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="comment">// 我们自己的命名空间</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">SplitBasicBlock</span> : <span class="keyword">public</span> FunctionPass <span class="comment">// 继承FunctionPass类</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="type">static</span> <span class="type">char</span> ID; <span class="comment">// 变量</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">SplitBasicBlock</span>() : <span class="built_in">FunctionPass</span>(ID) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp; F)</span></span>; <span class="comment">// runOnFunction函数声明</span></span><br><span class="line">            <span class="function"><span class="type">bool</span> <span class="title">containsPHI</span><span class="params">(BasicBlock *BB)</span></span>; <span class="comment">// 判断基本块有无PHI指令</span></span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(BasicBlock *BB)</span></span>; <span class="comment">// 对基本块进行分裂</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SplitBasicBlock::containsPHI</span><span class="params">(BasicBlock *BB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Instruction &amp;I : *BB) <span class="comment">// foreach循环遍历传入基本块的所有指令</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isa</span>&lt;PHINode&gt;(&amp;I)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//isa&lt;&gt;()判断类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SplitBasicBlock::split</span><span class="params">(BasicBlock *BB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> splitSize = (BB-&gt;<span class="built_in">size</span>() + splitNum - <span class="number">1</span>) / splitNum; <span class="comment">//向上取整计算出分裂后的基本块大小</span></span><br><span class="line">    BasicBlock *curBB = BB; <span class="comment">//由于分裂后基本块发生变化，先把基本块存下来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; splitNum; i++) <span class="comment">//分裂splitNum - 1次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 指令计数器</span></span><br><span class="line">        <span class="keyword">for</span>(Instruction &amp;I : *curBB) <span class="comment">//遍历所有指令</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt++ == splitSize) <span class="comment">//到达splitSize进行分裂</span></span><br><span class="line">            &#123;  </span><br><span class="line">                curBB = curBB-&gt;<span class="built_in">splitBasicBlock</span>(&amp;I); <span class="comment">//把当前指令和之前的分开，curBB进入到后面的基本快中</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SplitBasicBlock::runOnFunction</span><span class="params">(Function &amp; F)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;BasicBlock*&gt; orgBB; <span class="comment">// 先把F函数中的基本块给存起来</span></span><br><span class="line">    <span class="keyword">for</span>(BasicBlock &amp;BB : F)</span><br><span class="line">    &#123;</span><br><span class="line">        orgBB.<span class="built_in">push_back</span>(&amp;BB);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(BasicBlock *BB : orgBB) <span class="comment">// 遍历vector中的基本块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">containsPHI</span>(BB)) <span class="comment">// 如果不包含PHI指令，则进行分裂</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">split</span>(BB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FunctionPass* <span class="title">llvm::createSplitBasicBlockPass</span><span class="params">()</span> <span class="comment">//在 SplitBasicBlock.cpp 中实现 llvm::createSplitBasicBlock 函数：</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SplitBasicBlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> SplitBasicBlock::ID = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> RegisterPass&lt;SplitBasicBlock&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;split&quot;</span>, <span class="string">&quot;Split a basic block into multiple basic blocks.&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>我们还可以在 include 文件夹里注册 SplitBasicBlock Pass 方便写其他 LLVM Pass 的时候直接调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SPLIT_BASIC_BLOCK_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SPLIT_BASIC_BLOCK_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> llvm </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">FunctionPass* <span class="title">createSplitBasicBlockPass</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">// 在llvm命名空间里添加一个新函数</span></span><br><span class="line"><span class="comment">//这个函数将在 SplitBasicBlock.cpp 里实现</span></span><br><span class="line"><span class="comment">//这样的话其他 LLVM Pass 就可以通过引入头文件 SplitBasicBlock.h ，调用createSplitBasicBlockPass 函数来创建一个 SplitBasicBlock Pass，完成基本块的分割。</span></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://example.com">EPs1l0h</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://example.com/2022/11/09/LLVM%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/">https://example.com/2022/11/09/LLVM%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://example.com" target="_blank">EPs1l0h's Castle</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover1.jpg?raw=true" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/11/%E6%9C%80%E8%BF%91%E9%81%87%E5%88%B0%E7%9A%84VM%E9%A2%98/"><img class="prev-cover" src="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover3.jpg?raw=true" onerror="onerror=null;src='/img/404.gif'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">最近遇到的VM题</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/09/OLLVM%E2%80%94%E2%80%94%E5%A5%BD%E5%83%8F%E6%8C%96%E4%BA%86%E4%B8%AA%E5%A1%AB%E4%B8%8D%E4%B8%8A%E7%9A%84%E5%9D%91/"><img class="next-cover" src="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover1.jpg?raw=true" onerror="onerror=null;src='/img/404.gif'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">OLLVM——好像挖了个填不上的坑</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">EPs1l0h</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/EPs1l0h"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Spears shall be shaken! Shields shall be splintered! A sword day! A red day! Ere the sun rises!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">模块化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%8B%93%E5%B1%95"><span class="toc-number">1.2.</span> <span class="toc-text">可拓展</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">2.</span> <span class="toc-text">安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.</span> <span class="toc-text">下载源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91LLVM%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.2.</span> <span class="toc-text">编译LLVM项目</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84LLVM-Pass%E7%BC%96%E8%AF%91%EF%BC%88LLVM%E2%80%94%E2%80%94Hello-World-%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">一次简单的LLVM Pass编译（LLVM——Hello World!）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87"><span class="toc-number">3.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FunctionPass"><span class="toc-number">3.2.1.</span> <span class="toc-text">FunctionPass</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5"><span class="toc-number">3.3.</span> <span class="toc-text">实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Build"><span class="toc-number">3.3.1.</span> <span class="toc-text">Build</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Test"><span class="toc-number">3.3.2.</span> <span class="toc-text">Test</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transforms-include"><span class="toc-number">3.3.3.</span> <span class="toc-text">Transforms&#x2F;include</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transforms-src"><span class="toc-number">3.3.4.</span> <span class="toc-text">Transforms&#x2F;src</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMakeLists-txt"><span class="toc-number">3.3.5.</span> <span class="toc-text">CMakeLists.txt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#test-sh"><span class="toc-number">3.3.6.</span> <span class="toc-text">test.sh</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LLVM-IR"><span class="toc-number">4.</span> <span class="toc-text">LLVM IR</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IR-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">IR 的结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%85%B7%E4%BD%93%E7%9A%84IR%E4%BB%A3%E7%A0%81%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.</span> <span class="toc-text">一些具体的IR代码介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%88%E7%BB%93%E6%8C%87%E4%BB%A4%EF%BC%88Terminate-Instruction%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">终结指令（Terminate Instruction）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#retn"><span class="toc-number">5.1.1.</span> <span class="toc-text">retn</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#br"><span class="toc-number">5.1.2.</span> <span class="toc-text">br</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#icmp"><span class="toc-number">5.1.3.</span> <span class="toc-text">icmp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fcmp"><span class="toc-number">5.1.4.</span> <span class="toc-text">fcmp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch"><span class="toc-number">5.1.5.</span> <span class="toc-text">switch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4-Binary-Operations"><span class="toc-number">5.2.</span> <span class="toc-text">二元运算指令 Binary Operations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#add"><span class="toc-number">5.2.1.</span> <span class="toc-text">add</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sub"><span class="toc-number">5.2.2.</span> <span class="toc-text">sub</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sub-1"><span class="toc-number">5.2.3.</span> <span class="toc-text">sub</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#udiv"><span class="toc-number">5.2.4.</span> <span class="toc-text">udiv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sidv"><span class="toc-number">5.2.5.</span> <span class="toc-text">sidv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#urem"><span class="toc-number">5.2.6.</span> <span class="toc-text">urem</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#srem"><span class="toc-number">5.2.7.</span> <span class="toc-text">srem</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97-Bitwise-Binary-Operations"><span class="toc-number">5.3.</span> <span class="toc-text">按位二元运算 Bitwise Binary Operations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shl"><span class="toc-number">5.3.1.</span> <span class="toc-text">shl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lshr"><span class="toc-number">5.3.2.</span> <span class="toc-text">lshr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ashr"><span class="toc-number">5.3.3.</span> <span class="toc-text">ashr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#and"><span class="toc-number">5.3.4.</span> <span class="toc-text">and</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#or"><span class="toc-number">5.3.5.</span> <span class="toc-text">or</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xor"><span class="toc-number">5.3.6.</span> <span class="toc-text">xor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E5%92%8C%E5%AF%BB%E5%9D%80%E6%93%8D%E4%BD%9C-Memory-Access-and-Addressing-Operations"><span class="toc-number">5.4.</span> <span class="toc-text">内存访问和寻址操作 Memory Access and Addressing Operations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%8D%95%E8%B5%8B%E5%80%BC-Static-Single-Assignment"><span class="toc-number">5.4.1.</span> <span class="toc-text">静态单赋值 Static Single Assignment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#alloca"><span class="toc-number">5.4.2.</span> <span class="toc-text">alloca</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#store"><span class="toc-number">5.4.3.</span> <span class="toc-text">store</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#load"><span class="toc-number">5.4.4.</span> <span class="toc-text">load</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C-Conversion-Operations"><span class="toc-number">5.5.</span> <span class="toc-text">类型转换操作  Conversion Operations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#trunc%E2%80%A6to"><span class="toc-number">5.5.1.</span> <span class="toc-text">trunc…to</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zext%E2%80%A6to"><span class="toc-number">5.5.2.</span> <span class="toc-text">zext…to</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sext%E2%80%A6to"><span class="toc-number">5.5.3.</span> <span class="toc-text">sext…to</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C-Other-Operations"><span class="toc-number">5.6.</span> <span class="toc-text">其他操作 Other Operations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#phi-%E6%8C%87%E4%BB%A4"><span class="toc-number">5.6.1.</span> <span class="toc-text">phi 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select"><span class="toc-number">5.6.2.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call"><span class="toc-number">5.6.3.</span> <span class="toc-text">call</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA-LLVM-Pass-%E2%80%94%E2%80%94-LLVM-Hello-World"><span class="toc-number">6.</span> <span class="toc-text">第一个 LLVM Pass —— LLVM Hello World</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%9D%97%E5%88%86%E5%89%B2%E2%80%94%E2%80%94Split-Basic-Block"><span class="toc-number">7.</span> <span class="toc-text">基本块分割——Split Basic Block</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">7.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.2.</span> <span class="toc-text">实现</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/08/02/%E6%9F%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/" title="某病毒样本分析报告"><img src="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover1.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.gif'" alt="某病毒样本分析报告"/></a><div class="content"><a class="title" href="/2024/08/02/%E6%9F%90%E7%97%85%E6%AF%92%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A/" title="某病毒样本分析报告">某病毒样本分析报告</a><time datetime="2024-08-02T08:59:23.000Z" title="发表于 2024-08-02 16:59:23">2024-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/05/frida-lab%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/" title="frida-lab做题记录"><img src="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover2.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.gif'" alt="frida-lab做题记录"/></a><div class="content"><a class="title" href="/2024/06/05/frida-lab%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/" title="frida-lab做题记录">frida-lab做题记录</a><time datetime="2024-06-05T00:36:58.000Z" title="发表于 2024-06-05 08:36:58">2024-06-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/27/%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F-2024-re/" title="上海大学生-2024-re"><img src="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover2.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.gif'" alt="上海大学生-2024-re"/></a><div class="content"><a class="title" href="/2024/05/27/%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F-2024-re/" title="上海大学生-2024-re">上海大学生-2024-re</a><time datetime="2024-05-27T14:35:03.000Z" title="发表于 2024-05-27 22:35:03">2024-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/27/%E4%BA%AC%E9%BA%92CTF-2024-re-wp/" title="京麒CTF-2024-re-wp"><img src="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover2.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.gif'" alt="京麒CTF-2024-re-wp"/></a><div class="content"><a class="title" href="/2024/05/27/%E4%BA%AC%E9%BA%92CTF-2024-re-wp/" title="京麒CTF-2024-re-wp">京麒CTF-2024-re-wp</a><time datetime="2024-05-27T13:37:23.000Z" title="发表于 2024-05-27 21:37:23">2024-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/25/%E9%93%81%E4%B8%892024-re/" title="铁三2024-re"><img src="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover2.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.gif'" alt="铁三2024-re"/></a><div class="content"><a class="title" href="/2024/05/25/%E9%93%81%E4%B8%892024-re/" title="铁三2024-re">铁三2024-re</a><time datetime="2024-05-25T03:42:12.000Z" title="发表于 2024-05-25 11:42:12">2024-05-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover1.jpg?raw=true')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By EPs1l0h</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://example.com/2022/11/09/LLVM%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/'
    this.page.identifier = '/2022/11/09/LLVM%E2%80%94%E2%80%94%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/'
    this.page.title = 'LLVM——从入门到入土'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Disqus' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><div class="aplayer no-destroy" data-id="2981528901" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>