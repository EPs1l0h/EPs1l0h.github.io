<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>angr初探 | EPs1l0h's Castle</title><meta name="author" content="EPs1l0h"><meta name="copyright" content="EPs1l0h"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一些碎碎念本来是想学z3的，后来发现都要用 virtualenvwrapper ，既然都是符号执行，那就先试试angr的水吧。 本来是挺好配置环境的，但是之前那个ubuntu有问题怎么都配不上，无奈重装了一个虚拟机，捏妈，装了一晚上，加上下载中文包，啥也没干，被迫摆烂一天重新开始学。 不过令我高兴的是，新装的ubuntu可以支持和原系统共享剪贴板，好好好，终于可以永久告别啥指令都要建个文档用文件互">
<meta property="og:type" content="article">
<meta property="og:title" content="angr初探">
<meta property="og:url" content="https://example.com/2022/11/04/angr%E5%88%9D%E6%8E%A2/index.html">
<meta property="og:site_name" content="EPs1l0h&#39;s Castle">
<meta property="og:description" content="一些碎碎念本来是想学z3的，后来发现都要用 virtualenvwrapper ，既然都是符号执行，那就先试试angr的水吧。 本来是挺好配置环境的，但是之前那个ubuntu有问题怎么都配不上，无奈重装了一个虚拟机，捏妈，装了一晚上，加上下载中文包，啥也没干，被迫摆烂一天重新开始学。 不过令我高兴的是，新装的ubuntu可以支持和原系统共享剪贴板，好好好，终于可以永久告别啥指令都要建个文档用文件互">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover1.jpg?raw=true">
<meta property="article:published_time" content="2022-11-04T07:17:59.000Z">
<meta property="article:modified_time" content="2022-11-04T07:48:43.754Z">
<meta property="article:author" content="EPs1l0h">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover1.jpg?raw=true"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://example.com/2022/11/04/angr%E5%88%9D%E6%8E%A2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'angr初探',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-04 15:48:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover1.jpg?raw=true')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">EPs1l0h's Castle</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">angr初探</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-04T07:17:59.000Z" title="发表于 2022-11-04 15:17:59">2022-11-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-04T07:48:43.754Z" title="更新于 2022-11-04 15:48:43">2022-11-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="angr初探"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一些碎碎念"><a href="#一些碎碎念" class="headerlink" title="一些碎碎念"></a>一些碎碎念</h1><p>本来是想学z3的，后来发现都要用 virtualenvwrapper ，既然都是符号执行，那就先试试angr的水吧。</p>
<p>本来是挺好配置环境的，但是之前那个ubuntu有问题怎么都配不上，无奈重装了一个虚拟机，捏妈，装了一晚上，加上下载中文包，啥也没干，被迫摆烂一天重新开始学。</p>
<p>不过令我高兴的是，新装的ubuntu可以支持和原系统共享剪贴板，好好好，终于可以永久告别啥指令都要建个文档用文件互相传的日子喽。</p>
<p><img src="/2022/11/04/angr%E5%88%9D%E6%8E%A2/1688456-20220123163122018-416652634.png" alt></p>
<h1 id="angr介绍"><a href="#angr介绍" class="headerlink" title="angr介绍"></a>angr介绍</h1><p>angr 是一个基于符号执行和模拟执行的二进制框架，可以用在很多的场景，比如逆向分析，漏洞挖掘等。 </p>
<h2 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h2><p><img src="/2022/11/04/angr%E5%88%9D%E6%8E%A2/1688456-20220123163200344-1522450217.png" alt></p>
<p>假如我们遇到一道逆向分析题，正常的流程应该是：拖入IDApro一键F5反编译然后硬刚代码写exp得到flag使得该程序输入该flag可以输出“success”等提示字样。（bushi</p>
<p>假如有一堆if语句，分别是if(a&gt;b)，if(b&gt;c)……（<del>等等，这不是差分约束么</del>）</p>
<p>于是如果我有一个东西，可以自动分析这些语句的逻辑构造一个输入可以让程序跑到指定的一条语句，比如printf(“Oooooooops”);那么是不是就可以自动获取flag了？</p>
<p>更详细的解释是：根据符号执行，我们把input语句看作是获取一个符号值，分析该程序的每一个分支进行之后所得到的表达式，如果我们对其增加约束，由于angr里内置了一个z3求解器，所以我们就可以得到想要的输入值。</p>
<h1 id="virtualenvwrapper"><a href="#virtualenvwrapper" class="headerlink" title="virtualenvwrapper"></a>virtualenvwrapper</h1><p>首先是环境配置。virtualenvwrapper是一个虚拟的python环境，假如你再安装angr前安装了z3，那么二者会发生一些冲突，因此需要把二者的环境隔离开，创建一个新的虚拟环境。</p>
<h2 id="安装virtualenvwrapper"><a href="#安装virtualenvwrapper" class="headerlink" title="安装virtualenvwrapper"></a>安装virtualenvwrapper</h2><p>第一步：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-dev libffi-dev build-essential virtualenvwrapper </span><br></pre></td></tr></table></figure>
<p>正常都是没有问题的，如果这一步有问题建议直接remake，就像某彩笔一样。</p>
<p>然后配置环境变量：</p>
<p>先把“显示隐藏文件选项”勾选上，然后直接搜索.bashrc文件，打开后，在末尾加上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export WORKON_HOME=$HOME/Python-workhome</span><br><span class="line">source /usr/share/virtualenvwrapper/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure>
<p><img src="/2022/11/04/angr%E5%88%9D%E6%8E%A2/1688456-20220123163306877-1723424594.png" alt></p>
<p>保存后<code>source ~/.bashrc</code></p>
<p>然后<code>mkvirtualenv --python=$(which python3) angr &amp;&amp; pip install angr</code>安装即可，SG大爹说<img src="/2022/11/04/angr%E5%88%9D%E6%8E%A2/1688456-20220123163348009-1628723821.png" alt>但其实好像也没多长时间（捂脸）</p>
<h2 id="virtualenvwrapper的操作命令"><a href="#virtualenvwrapper的操作命令" class="headerlink" title="virtualenvwrapper的操作命令"></a>virtualenvwrapper的操作命令</h2><p>workon: 列出已有环境（我们只创建了叫angr的环境）</p>
<p><img src="/2022/11/04/angr%E5%88%9D%E6%8E%A2/1688456-20220123163420782-472894981.png" alt></p>
<p>workon angr: 切换到环境angr</p>
<p><img src="/2022/11/04/angr%E5%88%9D%E6%8E%A2/1688456-20220123163429324-1100126133.png" alt></p>
<p>deactivate: 退出环境</p>
<p><img src="/2022/11/04/angr%E5%88%9D%E6%8E%A2/1688456-20220123163437727-886781870.png" alt></p>
<p>rmvirtualenv: 删除环境 （这个就不试了）</p>
<h1 id="使用初探"><a href="#使用初探" class="headerlink" title="使用初探"></a>使用初探</h1><p>例题来自， <a target="_blank" rel="noopener" href="https://github.com/jakespringer/angr_ctf">https://github.com/jakespringer/angr_ctf</a> </p>
<h2 id="【例-1-1-explore】00-angr-find-（explore的find方法）"><a href="#【例-1-1-explore】00-angr-find-（explore的find方法）" class="headerlink" title="【例 1.1 - explore】00_angr_find （explore的find方法）"></a>【例 1.1 - explore】00_angr_find （explore的find方法）</h2><p><img src="/2022/11/04/angr%E5%88%9D%E6%8E%A2/1688456-20220123163450918-1425021860.png" alt></p>
<p>一个比较简单的程序，用angr尝试解一下。</p>
<p>我们发现只要程序运行到<code>puts(&quot;Good Job&quot;)</code>这一行那么我们就得到了flag，找到该语句地址： <img src="/2022/11/04/angr%E5%88%9D%E6%8E%A2/1688456-20220123163503579-1782898619.png" alt></p>
<p>题目名字就是hint，简单find，因为该程序计算量不大，即使自己分析也是可行的，此题仅作为练手。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">path = <span class="string">&#x27;/home/ep/桌面/00_angr_find&#x27;</span> <span class="comment"># 被执行文件的路径</span></span><br><span class="line">project = angr.Project(path) <span class="comment"># 以被执行文件创建angr项目</span></span><br><span class="line"></span><br><span class="line">init_state = project.factory.entry_state() <span class="comment"># entry_state()可以创建一个默认的初始状态，告诉angr该从哪开始</span></span><br><span class="line"></span><br><span class="line">simulation = project.factory.simgr(init_state) <span class="comment"># 以该初始状态创建一个模拟管理器，这个管理器还有很多工具可以帮助搜索和执行二进制文件</span></span><br><span class="line"></span><br><span class="line">aim_addr = <span class="number">0x804867D</span> <span class="comment"># 希望程序运行到的地址，也就是上图的地址</span></span><br><span class="line"></span><br><span class="line">simulation.explore(find = aim_addr) <span class="comment"># 开始执行，直到达到上述地址或者探索完所有可能的路径，simulation.explore()会建立一个名为simulation.found的状态列表</span></span><br><span class="line">                                    <span class="comment"># 该状态列表用来表示是否找到了期望的输出，若找到则为true，反之为false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found: <span class="comment"># 检查是否得到了解决方案</span></span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno())) <span class="comment"># 输出angr执行到该状态时的输入，也就是我们需要的flag</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>: <span class="comment"># 没有得到解决方案</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>进入angr环境后，运行得到flag。</p>
<p><img src="/2022/11/04/angr%E5%88%9D%E6%8E%A2/1688456-20220123163525949-122090149.png" alt></p>
<h2 id="【例-1-2-explore】01-angr-avoid-（explore的avoid方法）"><a href="#【例-1-2-explore】01-angr-avoid-（explore的avoid方法）" class="headerlink" title="【例 1.2 - explore】01_angr_avoid （explore的avoid方法）"></a>【例 1.2 - explore】01_angr_avoid （explore的avoid方法）</h2><p>IDApro打开后发现</p>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220206211938930-1339080774.png" alt></p>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220206211947512-191320298.png" alt></p>
<p>main函数里的内容太多了显示不下，留意函数名</p>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220206212001638-674287628.png" alt></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">avoid_me</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  should_succeed = <span class="number">0</span>;<span class="comment">//addr:080485AB</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">maybe_good</span><span class="params">(<span class="type">char</span> *s1, <span class="type">char</span> *s2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( should_succeed &amp;&amp; !<span class="built_in">strncmp</span>(s1, s2, <span class="number">8u</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);<span class="comment">//addr:080485E0</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目名字就是hint，和例1一样，加上avoid约束即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/home/ep/桌面/01_angr_avoid&#x27;</span>)<span class="comment">#创建项目</span></span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x80485E0</span>, avoid=<span class="number">0x80485A8</span>)<span class="comment">#由上述分析，添加find和avoid约束，如果不加avoid约束会跑大概一分钟，不加只需要几秒</span></span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220206212014519-1167011623.png" alt></p>
<h2 id="【例-1-3-explore】02-angr-find-condition-（以特定输出为出口）"><a href="#【例-1-3-explore】02-angr-find-condition-（以特定输出为出口）" class="headerlink" title="【例 1.3 - explore】02_angr_find_condition （以特定输出为出口）"></a>【例 1.3 - explore】02_angr_find_condition （以特定输出为出口）</h2><p>反编译后发现汇编代码只能用文本模式打开，可以看到有一堆puts(“Good Job.”)语句，可以反编译出正常代码说明这些函数都是一样的，但是对应的地址却有很多个，这样在使用angr的时候没有办法给出准确的addr，常规的写法已经不可行了。</p>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223221806368-1537919107.png" alt></p>
<p>好在 ，explore函数的find参数除了地址外，也可以是一个携带SimState参数的函数，我的理解是它不仅可以根据地址，也可以根据特定的输出来判定程序的出口。</p>
<p>根据C代码，发现我们需要该程序输出<code>Good Job</code>，不输出<code>Try again</code></p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __cdecl main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="built_in">char</span> **argv, <span class="keyword">const</span> <span class="built_in">char</span> **envp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [esp+18h] [ebp-40h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [esp+1Ch] [ebp-3Ch]</span></span><br><span class="line">  <span class="built_in">char</span> s1[<span class="number">20</span>]; <span class="comment">// [esp+24h] [ebp-34h] BYREF</span></span><br><span class="line">  <span class="built_in">char</span> s2[<span class="number">20</span>]; <span class="comment">// [esp+38h] [ebp-20h] BYREF</span></span><br><span class="line">  unsigned <span class="keyword">int</span> v8; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readgsdword(<span class="number">0</span>x14u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">19</span>; ++i )</span><br><span class="line">    s2[i] = <span class="number">0</span>;</span><br><span class="line">  qmemcpy(s2, <span class="string">&quot;VXRRJEUR&quot;</span>, <span class="number">8</span>);</span><br><span class="line">  printf(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%8s&quot;</span>, s1);</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">7</span>; ++j )</span><br><span class="line">    s1[j] = complex_function(s1[j], j + <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !strcmp(s1, s2) )</span><br><span class="line">    puts(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    puts(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是exp还可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)<span class="comment"># find &#x27;Good job&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">should_avoid</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)<span class="comment"># avoid &#x27;Try again&#x27;</span></span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/home/ep/桌面/02_angr_find_condition&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)<span class="comment">#以上和前面的写法是一样的</span></span><br><span class="line">simgr.explore(find=is_successful, avoid=should_avoid)<span class="comment">#自定义的携带state参数的函数</span></span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>还可以借助python的lambda公式来写脚本，其实也可以理解为函数</p>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223221853160-686064249.png" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/home/ep/桌面/02_angr_find_condition&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(</span><br><span class="line">    find=<span class="keyword">lambda</span> state : <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>),</span><br><span class="line">    avoid=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>运行得到flag：</p>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223221842822-983589310.png" alt></p>
<h2 id="【例-2-1-symbolic】03-angr-symbolic-registers-（对寄存器符号化）"><a href="#【例-2-1-symbolic】03-angr-symbolic-registers-（对寄存器符号化）" class="headerlink" title="【例 2.1 - symbolic】03_angr_symbolic_registers （对寄存器符号化）"></a>【例 2.1 - symbolic】03_angr_symbolic_registers （对寄存器符号化）</h2><p>反编译后，源代码逻辑比较简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 user_input; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  user_input = get_user_input();</span><br><span class="line">  v7 = HIDWORD(user_input);</span><br><span class="line">  v5 = complex_function_1(user_input);</span><br><span class="line">  v6 = complex_function_2();</span><br><span class="line">  v8 = complex_function_3(v7);</span><br><span class="line">  <span class="keyword">if</span> ( v5 || v6 || v8 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是complex函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __cdecl <span class="title function_">complex_function_1</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (((((((((((((((((((((a1 + <span class="number">17062705</span>) ^ <span class="number">0xB168C552</span>) + <span class="number">647103529</span>) ^ <span class="number">0x9F14CFD7</span>) - <span class="number">548738866</span>) ^ <span class="number">0xF78063EF</span>)</span><br><span class="line">                      - <span class="number">1352480098</span>) ^ <span class="number">0x5D1F4C6</span>)</span><br><span class="line">                    - <span class="number">57802472</span>) ^ <span class="number">0xB6F70BF8</span>)</span><br><span class="line">                  - <span class="number">1347645151</span></span><br><span class="line">                  + <span class="number">648671421</span>) ^ <span class="number">0x3D5082FE</span>)</span><br><span class="line">                - <span class="number">9365053</span>) ^ <span class="number">0xD0150EAD</span>)</span><br><span class="line">              + <span class="number">1067946459</span>) ^ <span class="number">0xE6E03877</span>)</span><br><span class="line">            - <span class="number">359192087</span></span><br><span class="line">            + <span class="number">961945065</span>) ^ <span class="number">0xE1EECD69</span>)</span><br><span class="line">          - <span class="number">1817072919</span>) ^ <span class="number">0x6B86ECF5</span>)</span><br><span class="line">        - <span class="number">449212884</span>) ^ <span class="number">0x2012CCDB</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没法逆向，考虑用angr。</p>
<p>当然强行explore也是能出的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/home/ep/桌面/03_angr_symbolic_registers&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x80489E9</span>,avoid=<span class="number">0x80489DC</span>)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223221909364-576875980.png" alt></p>
<p> 但是根据题目要求，本题需要用手动符号化与约束求解。</p>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223221921058-1407890513.png" alt></p>
<p>由红色方框中的指令可以看出，get_user_input之后，输入的三个数分别存在寄存器eax,ebx,ecx中，可以把这三个寄存器符号化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">b = claripy.BVS(<span class="string">&#x27;password2&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">c = claripy.BVS(<span class="string">&#x27;password3&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">state.regs.eax = a</span><br><span class="line">state.regs.ebx = b</span><br><span class="line">state.regs.edx = c</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在angr中，无论是具体值还是符号量都有相同的类型——claripy.ast.bv.BV，也就是BitVector的意思，BV后面的数字表示这个比特向量的位数。</p>
</blockquote>
<p>BV可以通过claripy这个模块创建：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>claripy.BVV(<span class="number">666</span>, <span class="number">32</span>)        <span class="comment"># 创建一个32位的有具体值的BV</span></span><br><span class="line">&lt;BV32 <span class="number">0x29a</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>claripy.BVS(<span class="string">&#x27;sym_var&#x27;</span>, <span class="number">32</span>)  <span class="comment"># 创建一个32位的符号值BV</span></span><br><span class="line">&lt;BV32 sym_var_97_32&gt;</span><br></pre></td></tr></table></figure>
<p>然后让程序跑到0x080489E6这个地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simgr.explore(find=<span class="number">0x80489E6</span>) <span class="comment">#输出&quot;Good Job&quot;的地方</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223221937177-132581071.png" alt></p>
<p>这样在确定了目标地址的状态下，<strong>angr内置的求解器会自动保存路径约束</strong>，从而解出三个输入值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">solver = simgr.found[<span class="number">0</span>].solver</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password0: <span class="subst">&#123;<span class="built_in">hex</span>(solver.<span class="built_in">eval</span>(a))&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password1: <span class="subst">&#123;<span class="built_in">hex</span>(solver.<span class="built_in">eval</span>(b))&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password2: <span class="subst">&#123;<span class="built_in">hex</span>(solver.<span class="built_in">eval</span>(c))&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>放上完整exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/home/ep/桌面/03_angr_symbolic_registers&#x27;</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x8048980</span>) <span class="comment">#这里的初始state是通过blank_state函数而不是entry_state函数获得的，跳过了输入</span></span><br><span class="line">a = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">32</span>) <span class="comment">#32位寄存器，需要创建一个32位的符号值BV，名称为password0,1,2</span></span><br><span class="line">b = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">c = claripy.BVS(<span class="string">&#x27;password2&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">state.regs.eax = a <span class="comment">#把符号值BV赋值给三个寄存器，以上操作相当于把三个寄存器符号化</span></span><br><span class="line">state.regs.ebx = b</span><br><span class="line">state.regs.edx = c</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x80489E6</span>) <span class="comment">#让程序跑到这个地址</span></span><br><span class="line">solver = simgr.found[<span class="number">0</span>].solver <span class="comment">#求解器根据路径约束求解输入值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">hex</span>(solver.<span class="built_in">eval</span>(a))&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">hex</span>(solver.<span class="built_in">eval</span>(b))&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;<span class="built_in">hex</span>(solver.<span class="built_in">eval</span>(c))&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>注意这里的初始state是通过blank_state函数而不是entry_state函数获得的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x8048980</span>)</span><br></pre></td></tr></table></figure>
<p>因为在0x8048980之前的指令对我们的求解其实是没有任何作用的，包括get_user_input函数，因为接下来我们就要将get_user_input函数的结果符号化了，而不是让angr自动帮我们符号化通过scanf读取的数据。同时， 根据x86汇编常识，像<strong>eax，ebx，ecx这样的寄存器是上下文无关</strong>的，也就是说一个函数内不会引用在函数外部设置的eax，ebx或者ecx的值，而是在<strong>函数内部对寄存器重新初始化并使用</strong>，因此也不用担心寄存器的初始化问题。</p>
<p>所以我们用blank_state获取的状态，即时初始的一些寄存器处于未初始化状态也是丝毫没有影响的，因为它们马上就会被初始化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs.ecx</span><br><span class="line">&lt;BV32 reg_c_3_32&#123;UNINITIALIZED&#125;&gt;</span><br></pre></td></tr></table></figure>
<p>至于esp，angr会给他们一个默认的初值，使接下来的函数调用不会爆炸：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs.esp</span><br><span class="line">&lt;BV32 <span class="number">0x7fff0000</span>&gt;</span><br></pre></td></tr></table></figure>
<p>ebp的初始值仍然是未初始化的，但对我们后续的符号执行没有影响，不管它就行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs.ebp</span><br><span class="line">&lt;BV32 reg_1c_3_32&#123;UNINITIALIZED&#125;&gt;</span><br></pre></td></tr></table></figure>
<h2 id="【例-2-2-symbolic】04-angr-symbolic-stack-（对栈空间内的数据符号化）"><a href="#【例-2-2-symbolic】04-angr-symbolic-stack-（对栈空间内的数据符号化）" class="headerlink" title="【例 2.2 - symbolic】04_angr_symbolic_stack （对栈空间内的数据符号化）"></a>【例 2.2 - symbolic】04_angr_symbolic_stack （对栈空间内的数据符号化）</h2><p>反编译得到C语言代码，代码逻辑比较简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">handle_user</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v2[<span class="number">3</span>]; <span class="comment">// [esp+Ch] [ebp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u %u&quot;</span>, v2, &amp;v1);</span><br><span class="line">  v2[<span class="number">0</span>] = complex_function0(v2[<span class="number">0</span>]);</span><br><span class="line">  v1 = complex_function1(v1);</span><br><span class="line">  <span class="keyword">if</span> ( v2[<span class="number">0</span>] == <span class="number">1999643857</span> &amp;&amp; v1 == <span class="number">-1136455217</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在【例 2.1】中我们了解了寄存器的符号化，接下来再看看如何对栈空间内的数据进行符号化 。</p>
<p>还是先从scanf语句后开始看,用<strong>blank_state</strong>跳过输入</p>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223221952966-1680809649.png" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x8048694</span>)</span><br></pre></td></tr></table></figure>
<p>在【例 2.1】文末中我们知道通过blank_state获取初始状态，ebp的值是未约束的。</p>
<p>因此在本题中，我们要向栈中push符号值，并且通过ebp索引这些符号值（比如<code>[ebp+var_10][ebp+var_C]</code>），所以我们得让ebp有一个正确的初值。</p>
<blockquote>
<p>前置芝士：</p>
<p>intel系统中栈是向下生长的(栈越扩大其值越小,堆恰好相反) </p>
<p>（1）ESP：栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。<br>（2）EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。 </p>
<p>根据上述的定义,在通常情况下ESP是可变的,随着栈的生产而逐渐变小,而EBP寄存器是固定的,只有当函数的调用后,发生入栈操作而改变。</p>
<p>在上述的定义中使用ESP来标记栈的底部，他随着栈的变化而变化</p>
<p>pop ebp; 出栈 栈扩大4byte 因为ebp为32位</p>
<p>push ebp; 入栈，栈减少4byte</p>
<p>add esp, 0Ch; 表示栈减小12byte</p>
<p>sub esp, 0Ch; 表示栈扩大12byte</p>
<p>由于以下遇到的寄存器为32位，因此每push一次会偏移4byte</p>
</blockquote>
<p>而之所以说是正确的初值，是因为我们<strong>跳过了函数开头对栈的调整</strong>，因此我们还需要手动调整ebp的值来保证栈帧平衡：</p>
<p> <img src="https://bluesadi.github.io/0x401RevTrain-Tools/angr/img/image-20211004000749119.png" alt="image-20211004000749119"> </p>
<blockquote>
<p>汇编语言补充知识：mov是赋值，比如mov ebp,esp，是指将esp中的内容赋值给ebp，lea是赋地址，lea eax,[ebp+var_10]就是把该地址赋给eax</p>
</blockquote>
<p>因此ebp的偏移量为<strong>0x18+4+4+4+4=40</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state.regs.ebp = state.regs.esp + <span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>通过对scanf之后汇编语言的分析，我们发现输入值应该存在[ebp+var_C]和[ebp+var_10]两个位置</p>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223222024299-257370539.png" alt></p>
<p>于是esp的值执行调整，使我们接下来push进去的符号值恰好在<strong>[ebp+var_10]和[ebp+var_C]</strong>这两个位置，push完之后要把esp调回来即可，放上完整脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/home/ep/桌面/04_angr_symbolic_stack&#x27;</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x8048694</span>) <span class="comment">#从输入语句开始执行</span></span><br><span class="line">state.regs.ebp = state.regs.esp + <span class="number">40</span> <span class="comment">#计算出ebp的偏移量，手动调整ebp的初值</span></span><br><span class="line">state.regs.esp = state.regs.ebp - <span class="number">0xC</span> + <span class="number">4</span></span><br><span class="line">password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">state.stack_push(password0)</span><br><span class="line">state.stack_push(password1)</span><br><span class="line">state.regs.esp = state.regs.ebp - <span class="number">40</span> <span class="comment">#把esp的值调整回来</span></span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x80486E1</span>)</span><br><span class="line">solver = simgr.found[<span class="number">0</span>].solver</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password0: <span class="subst">&#123;<span class="built_in">hex</span>(solver.<span class="built_in">eval</span>(password0))&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password1: <span class="subst">&#123;<span class="built_in">hex</span>(solver.<span class="built_in">eval</span>(password1))&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>得到输入值</p>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223222048185-67585126.png" alt></p>
<h2 id="【例-2-3-symbolic】05-angr-symbolic-memory-（对内存符号化）"><a href="#【例-2-3-symbolic】05-angr-symbolic-memory-（对内存符号化）" class="headerlink" title="【例 2.3 - symbolic】05_angr_symbolic_memory  （对内存符号化）"></a>【例 2.3 - symbolic】05_angr_symbolic_memory  （对内存符号化）</h2><p>代码逻辑还是比较简单：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(user_input, <span class="number">0</span>, <span class="number">0x21</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%8s %8s %8s %8s&quot;</span>, user_input, &amp;unk_A1BA1C8, &amp;unk_A1BA1D0, &amp;unk_A1BA1D8);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">    *(_BYTE *)(i + <span class="number">169583040</span>) = complex_function(*(<span class="type">char</span> *)(i + <span class="number">169583040</span>), i);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(user_input, <span class="string">&quot;NJPURZPCDYEAXCSJZJMPSOMBFDDLHBVN&quot;</span>, <span class="number">0x20</span>u) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出输入是存在一个<code>user_input</code>全局变量里，且起始地址为<strong>0A1BA1C9</strong>： <img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223222059646-688942475.png" alt></p>
<p>我们只需要对<code>user_input</code>进行符号化即可，也就是对0xA1BA1C0开始的32字节内存进行符号化，符号化方式有两种：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">password2 = claripy.BVS(<span class="string">&#x27;password2&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">password3 = claripy.BVS(<span class="string">&#x27;password3&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">state.mem[<span class="number">0xA1BA1C0</span>].uint64_t = password0</span><br><span class="line">state.mem[<span class="number">0xA1BA1C0</span> + <span class="number">8</span>].uint64_t = password1</span><br><span class="line">state.mem[<span class="number">0xA1BA1C0</span> + <span class="number">16</span>].uint64_t = password2</span><br><span class="line">state.mem[<span class="number">0xA1BA1C0</span> + <span class="number">24</span>].uint64_t = password3</span><br></pre></td></tr></table></figure>
<p>或者根据上图的地址（两种方法等效）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">state.memory.store(<span class="number">0x0A1BA1C0</span>, flag_0)</span><br><span class="line">state.memory.store(<span class="number">0x0A1BA1C8</span>, flag_1)</span><br><span class="line">state.memory.store(<span class="number">0x0A1BA1D0</span>, flag_2)</span><br><span class="line">state.memory.store(<span class="number">0x0A1BA1D8</span>, flag_3)</span><br></pre></td></tr></table></figure>
<p>如果我们要获取内存中的数据（具体值或者符号值），可以这样用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.mem[<span class="number">0xA1BA1C0</span>].uint64_t.resolved</span><br><span class="line">&lt;BV64 password0_0_64&gt;</span><br></pre></td></tr></table></figure>
<p>下面放上完整exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/home/ep/桌面/05_angr_symbolic_memory&#x27;</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x80485FE</span>) <span class="comment">#跳过输入</span></span><br><span class="line">a = claripy.BVS(<span class="string">&#x27;flag0&#x27;</span>, <span class="number">64</span>) <span class="comment">#每个char字符为8字节，因此每个%8s输入8个字符就是64字节</span></span><br><span class="line">b = claripy.BVS(<span class="string">&#x27;flag1&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">c = claripy.BVS(<span class="string">&#x27;flag2&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">d = claripy.BVS(<span class="string">&#x27;flag3&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">state.mem[<span class="number">0xA1BA1C0</span>].uint64_t = a <span class="comment">#赋值给特定内存</span></span><br><span class="line">state.mem[<span class="number">0xA1BA1C0</span> + <span class="number">8</span>].uint64_t = b</span><br><span class="line">state.mem[<span class="number">0xA1BA1C0</span> + <span class="number">16</span>].uint64_t = c</span><br><span class="line">state.mem[<span class="number">0xA1BA1C0</span> + <span class="number">24</span>].uint64_t = d</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x804866A</span>) <span class="comment">#&#x27;Good Job.&#x27;</span></span><br><span class="line">solver = simgr.found[<span class="number">0</span>].solver</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;flag0: <span class="subst">&#123;solver.<span class="built_in">eval</span>(a, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;flag1: <span class="subst">&#123;solver.<span class="built_in">eval</span>(b, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;flag2: <span class="subst">&#123;solver.<span class="built_in">eval</span>(c, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;flag3: <span class="subst">&#123;solver.<span class="built_in">eval</span>(d, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223222115775-897640348.png" alt></p>
<p>当然也可以把四个数据放在一起写，但是结果和上面那个方法是相反的，应该是端序问题，不太清楚。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/home/ep/桌面/05_angr_symbolic_memory&#x27;</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x80485FE</span>) <span class="comment">#跳过输入</span></span><br><span class="line"></span><br><span class="line">flag = claripy.BVS(<span class="string">&#x27;flag&#x27;</span>, <span class="number">64</span> * <span class="number">4</span>)</span><br><span class="line">state.memory.store(<span class="number">0xA1BA1C0</span>, flag)</span><br><span class="line"></span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x804866A</span>) <span class="comment">#&#x27;Good Job.&#x27;</span></span><br><span class="line">solver = simgr.found[<span class="number">0</span>].solver</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;flag: <span class="subst">&#123;solver.<span class="built_in">eval</span>(flag, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223222128998-250664337.png" alt></p>
<p>这里我们在使用eval时多了一个参数<strong>cast_to</strong>，该参数可以指定把结果映射到哪种数据类型。</p>
<p>顺便，我们引申一些eval的其他用法</p>
<ul>
<li><code>solver.eval(expression)</code> 解出一个可行解</li>
<li><code>solver.eval_one(expression)</code> 给出一个表达式的唯一可行解，若有多个可行解，则抛出异常。</li>
<li><code>solver.eval_upto(expression, n)</code> 给出最多n个可行解，如果不足n个就给出所有的可行解。</li>
<li><code>solver.eval_exact(expression, n)</code> 给出精确的n个可行解，如果解的个数不等于n个，将会抛出异常。</li>
<li><code>solver.min(expression)</code> 给出最小可行解</li>
<li><code>solver.max(expression)</code> 给出最大可行解</li>
</ul>
<h2 id="【例-2-4-symbolic】06-angr-symbolic-dynamic-memory-（对动态内存的符号化）"><a href="#【例-2-4-symbolic】06-angr-symbolic-dynamic-memory-（对动态内存的符号化）" class="headerlink" title="【例 2.4 - symbolic】06_angr_symbolic_dynamic_memory （对动态内存的符号化）"></a>【例 2.4 - symbolic】06_angr_symbolic_dynamic_memory （对动态内存的符号化）</h2><p> 这题使用了malloc函数来动态分配内存，因此输入的地址就不是固定的了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v3; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [esp-10h] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+0h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  buffer0 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">9u</span>);</span><br><span class="line">  buffer1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">9u</span>); <span class="comment">// malloc分配动态内存</span></span><br><span class="line">  <span class="built_in">memset</span>(buffer0, <span class="number">0</span>, <span class="number">9u</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buffer1, <span class="number">0</span>, <span class="number">9u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%8s %8s&quot;</span>, buffer0, buffer1, v6);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = &amp;buffer0[i];</span><br><span class="line">    *v3 = complex_function(buffer0[i], i);</span><br><span class="line">    v4 = &amp;buffer1[i];</span><br><span class="line">    *v4 = complex_function(buffer1[i], i + <span class="number">32</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(buffer0, <span class="string">&quot;UODXLZBI&quot;</span>, <span class="number">8u</span>) &amp;&amp; !<span class="built_in">strncmp</span>(buffer1, <span class="string">&quot;UAORRAYF&quot;</span>, <span class="number">8u</span>) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(buffer0);</span><br><span class="line">  <span class="built_in">free</span>(buffer1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到输入是两个长度为8的字符串buffer0和buffer1。虽然malloc是随机分配的，但是由于<strong>angr其实并没有真正运行过源程序</strong>，因此我们可以<strong>直接指定一段地址区间存储该字符串</strong></p>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223222139497-1136922604.png" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flag0 = claripy.BVS(<span class="string">&#x27;flag0&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">flag1 = claripy.BVS(<span class="string">&#x27;flag1&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">state.memory.store(<span class="number">0x8274600</span>, flag0)</span><br><span class="line">state.memory.store(<span class="number">0x8274608</span>, flag1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二种方法</span></span><br><span class="line">state.mem[<span class="number">0x8274600</span>].uint64_t = flag0</span><br><span class="line">state.mem[<span class="number">0x8274608</span>].uint64_t = flag1</span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223222145728-141408855.png" alt></p>
<p>然后找到buffer0和buffer1的真实地址并改成之前选定的假地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">state.memory.store(<span class="number">0xABCC8A4</span>, <span class="number">0x8274600</span>, endness = proj.arch.memory_endness)</span><br><span class="line">state.memory.store(<span class="number">0xABCC8AC</span>, <span class="number">0x8274608</span>, endness = proj.arch.memory_endness)</span><br><span class="line"><span class="comment">#endness = proj.arch.memory_endness用来调成小端序，angr默认是大端序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#第二种方法</span></span><br><span class="line">state.mem[<span class="number">0xABCC8A4</span>].uint32_t = <span class="number">0x8274600</span></span><br><span class="line">state.mem[<span class="number">0xABCC8AC</span>].uint32_t = <span class="number">0x8274608</span></span><br></pre></td></tr></table></figure>
<p>接下来的操作和之前就一样了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/home/ep/桌面/06_angr_symbolic_dynamic_memory&#x27;</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x8048696</span>)</span><br><span class="line">flag0 = claripy.BVS(<span class="string">&#x27;flag0&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">flag1= claripy.BVS(<span class="string">&#x27;flag1&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">state.memory.store(<span class="number">0xABCC8A4</span>, <span class="number">0x8274600</span>, endness = proj.arch.memory_endness)</span><br><span class="line">state.memory.store(<span class="number">0xABCC8AC</span>, <span class="number">0x8274608</span>, endness = proj.arch.memory_endness)</span><br><span class="line">state.memory.store(<span class="number">0x8274600</span>, flag0)</span><br><span class="line">state.memory.store(<span class="number">0x8274608</span>, flag1)</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x8048759</span>)</span><br><span class="line">solver = simgr.found[<span class="number">0</span>].solver</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;flag0: <span class="subst">&#123;solver.<span class="built_in">eval</span>(flag0, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;flag1: <span class="subst">&#123;solver.<span class="built_in">eval</span>(flag1, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223222156290-1674623415.png" alt></p>
<h2 id="【例-2-5-symbolic】07-angr-symbolic-file-（对文件内容符号化）"><a href="#【例-2-5-symbolic】07-angr-symbolic-file-（对文件内容符号化）" class="headerlink" title="【例 2.5 - symbolic】07_angr_symbolic_file （对文件内容符号化）"></a>【例 2.5 - symbolic】07_angr_symbolic_file （对文件内容符号化）</h2><p>C代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%64s&quot;</span>, buffer);</span><br><span class="line">  ignore_me((<span class="type">int</span>)buffer, <span class="number">0x40</span>u); <span class="comment">//ignore_me函数如其名，应该跳过</span></span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">  fp = fopen(<span class="string">&quot;OJKSQYDP.txt&quot;</span>, <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">  fread(buffer, <span class="number">1u</span>, <span class="number">0x40</span>u, fp);</span><br><span class="line">  fclose(fp);</span><br><span class="line">  unlink(<span class="string">&quot;OJKSQYDP.txt&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i )</span><br><span class="line">    *(_BYTE *)(i + <span class="number">134520992</span>) = complex_function(*(<span class="type">char</span> *)(i + <span class="number">134520992</span>), i);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(buffer, <span class="string">&quot;AQWLCTXB&quot;</span>, <span class="number">9u</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在这题中我们要忽略scanf，直接对文件的内容进行符号化。要对文件内容进行符号化，首先我们要创建一个<strong>模拟的文件<code>SimFile</code></strong>，文件名为’OJKSQYDP.txt’，内容为8字节的符号值，大小为0x40字节，然后插入到<strong>state的文件系统（FileSystem）</strong>中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/home/ep/桌面/07_angr_symbolic_file&#x27;</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x80488D3</span>) <span class="comment">#从ignore_me函数往下开始跑</span></span><br><span class="line">flag = claripy.BVS(<span class="string">&#x27;flag&#x27;</span>, <span class="number">64</span>) <span class="comment">#长度为 0x40</span></span><br><span class="line">sim_file = angr.SimFile(name=<span class="string">&#x27;OJKSQYDP.txt&#x27;</span>, content=flag, size=<span class="number">0x40</span>) <span class="comment">#创建一个模拟文件</span></span><br><span class="line">state.fs.insert(<span class="string">&#x27;OJKSQYDP.txt&#x27;</span>, sim_file) <span class="comment">#用simstate.fs将文件加入state的文件系统中</span></span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x80489AD</span>)</span><br><span class="line">solver = simgr.found[<span class="number">0</span>].solver</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;flag: <span class="subst">&#123;solver.<span class="built_in">eval</span>(flag, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223222208789-1866810146.png" alt></p>
<h2 id="【例-3-1-constraints】08-angr-constraints-（手动添加约束避免路径爆炸）"><a href="#【例-3-1-constraints】08-angr-constraints-（手动添加约束避免路径爆炸）" class="headerlink" title="【例 3.1 - constraints】08_angr_constraints （手动添加约束避免路径爆炸）"></a>【例 3.1 - constraints】08_angr_constraints （手动添加约束避免路径爆炸）</h2><p>C代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  qmemcpy(&amp;password, <span class="string">&quot;AUPDNNPROEZRJWKB&quot;</span>, <span class="number">16</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buffer, <span class="number">0</span>, <span class="number">0x11</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%16s&quot;</span>, &amp;buffer);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">    *(_BYTE *)(i + <span class="number">134520912</span>) = complex_function(*(<span class="type">char</span> *)(i + <span class="number">134520912</span>), <span class="number">15</span> - i);</span><br><span class="line">  <span class="keyword">if</span> ( check_equals_AUPDNNPROEZRJWKB(&amp;buffer, <span class="number">16</span>) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>找到关键函数<code>check_equals_AUPDNNPROEZRJWKB</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_BOOL4 __cdecl <span class="title function_">check_equals_AUPDNNPROEZRJWKB</span><span class="params">(<span class="type">int</span> a1, <span class="type">unsigned</span> <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [esp+8h] [ebp-8h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [esp+Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a2; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(_BYTE *)(i + a1) == *(_BYTE *)(i + <span class="number">134520896</span>) )</span><br><span class="line">      ++v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3 == a2;<span class="comment">//跑完16位再比较是否匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，字符长度为16， 只有和目标串全部匹配一边并且相同才会让v3==v2，而不是只要配对失败就退出循环，根据<strong>搜索树</strong>，每判断一位字符就出现了两个分支，直到到达第16层，出现了$2^{16}$个分支才能最终确定每一位是什么（如果逐字符判断，如果哪一位不对直接退出循环，就相当于加了个剪枝，效率就大大提升，但是本体的写法比较丑），因此对于这种逻辑非常简单，并且会引起<strong>路径爆炸</strong>的代码我们可以选择手动添加约束并且让程序停止在该代码之前来解决。</p>
<p>完整exp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/home/ep/桌面/08_angr_constraints&#x27;</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x8048622</span>)</span><br><span class="line">flag = claripy.BVS(<span class="string">&#x27;flag&#x27;</span>, <span class="number">16</span> * <span class="number">8</span>)</span><br><span class="line">buffer_addr = <span class="number">0x804A050</span> <span class="comment">#找到buffer数组的地址</span></span><br><span class="line">state.memory.store(buffer_addr, flag) <span class="comment">#将该地址往后 16 * 8 的内存符号化</span></span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x8048669</span>) <span class="comment">#跑到check函数之前停下</span></span><br><span class="line">found = simgr.found[<span class="number">0</span>] <span class="comment">#读取当前的simstate状态，为下一步手动添加约束做准备</span></span><br><span class="line">found.add_constraints(found.memory.load(buffer_addr, <span class="number">16</span>) == <span class="string">b&#x27;AUPDNNPROEZRJWKB&#x27;</span>) </span><br><span class="line"><span class="comment">#手动添加约束，check的函数名是提示，直接把后缀拿来用就行了</span></span><br><span class="line"><span class="comment">#found.memory.load(addr, size)接口可读取内存数据</span></span><br><span class="line"><span class="built_in">print</span>(found.solver.<span class="built_in">eval</span>(flag, cast_to=<span class="built_in">bytes</span>))</span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223222226292-1250895364.png" alt></p>
<ul>
<li><strong>路径爆炸</strong></li>
</ul>
<blockquote>
<p>路径爆炸的概念与数学中的<strong>指数爆炸</strong>概念类似，即某些情况下符号执行的路径/状态以指数级增长。</p>
<p>从<code>08_angr_constraints</code>中我们发现，即使是非常简单的比较函数，也可能让angr产生指数级的路径（216条路径），耗费大量时间甚至根本跑不出来，这就是符号执行的重大缺陷之一——路径爆炸。这既是我们在用符号执行解决实际问题时需要注意的问题，也是一种可以用来抗符号执行的思路。</p>
<p>应对路径爆炸的方法有很多，甚至还有专门的论文来讲述缓解路径爆炸的方法，在上一题中我们学到了最简单的一种：避开会产生路径爆炸的函数，用手动添加约束替代，这是最简单，也是非常好用的一种方法。总的来说，读者们在使用符号执行引擎时，要识别那些会导致路径爆炸的代码，并巧妙绕过。</p>
</blockquote>
<h2 id="【例-4-1-hooks】09-angr-hooks-（对call指令进行hook避免路径爆炸）"><a href="#【例-4-1-hooks】09-angr-hooks-（对call指令进行hook避免路径爆炸）" class="headerlink" title="【例 4.1 - hooks】09_angr_hooks （对call指令进行hook避免路径爆炸）"></a>【例 4.1 - hooks】09_angr_hooks （对call指令进行hook避免路径爆炸）</h2><p>反编译发现不同于【例 3.1】，本题的check出现在中间，因此无法使用上题手动添加约束的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BOOL4 v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  qmemcpy(password, <span class="string">&quot;XYMKBKUHNIQYNQXE&quot;</span>, <span class="number">16</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="number">0x11</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%16s&quot;</span>, buffer);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">    *(_BYTE *)(i + <span class="number">134520916</span>) = complex_function(*(<span class="type">char</span> *)(i + <span class="number">134520916</span>), <span class="number">18</span> - i);</span><br><span class="line">  equals = check_equals_XYMKBKUHNIQYNQXE(buffer, <span class="number">16</span>);<span class="comment">//引起路径爆炸的check函数</span></span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">15</span>; ++j )</span><br><span class="line">    *(_BYTE *)(j + <span class="number">134520900</span>) = complex_function(*(<span class="type">char</span> *)(j + <span class="number">134520900</span>), j + <span class="number">9</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%16s&quot;</span>, buffer);</span><br><span class="line">  v3 = equals &amp;&amp; !<span class="built_in">strncmp</span>(buffer, password, <span class="number">0x10</span>u);</span><br><span class="line">  equals = v3;</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于check_equals函数本身的流程非常简单，那么我们就可以用hook（钩子）技术将<code>check_equals</code>函数替换为一个<strong>等效的并且不会导致路径爆炸的函数</strong>，然后再进行符号执行 ，先找到代替换函数的入口地址：</p>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223222250930-455507145.png" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@proj.hook(<span class="params">addr=<span class="number">0x80486B3</span>, length=<span class="number">5</span></span>)</span></span><br><span class="line"><span class="comment"># check_equals_XYMKBKUHNIQYNQXE的地址</span></span><br><span class="line"><span class="comment">#注意这里的hook是对call指令进行了hook，而不是函数本身，length指的是跳过的字节数，call指令占5个字节，所以length=5</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_check_equals</span>(<span class="params">state</span>):</span><br><span class="line">    buffer_addr = <span class="number">0x804A054</span> <span class="comment">#buffer的地址</span></span><br><span class="line">    buffer = state.memory.load(buffer_addr, <span class="number">16</span>) <span class="comment">#载入16个字符</span></span><br><span class="line">    state.regs.eax = claripy.If(buffer == <span class="string">b&#x27;XYMKBKUHNIQYNQXE&#x27;</span>, claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), claripy.BVV(<span class="number">0</span>, <span class="number">32</span>))</span><br></pre></td></tr></table></figure>
<p>这里解释一下<code>claripy.If(lambda,a,b)</code>，该表达式的意思是如果表达式labmda成立，则返回a，也就是数字1（32位），否则返回b，也就是数字0（32位）。</p>
<p>解决了路径爆炸以后，直接explore即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/home/ep/桌面/09_angr_hooks&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@proj.hook(<span class="params">addr=<span class="number">0x80486B3</span>, length=<span class="number">5</span></span>)  </span><span class="comment"># check_equals_XYMKBKUHNIQYNQXE</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_check_equals</span>(<span class="params">state</span>):</span><br><span class="line">    buffer_addr = <span class="number">0x804A054</span></span><br><span class="line">    buffer = state.memory.load(buffer_addr, <span class="number">16</span>)</span><br><span class="line">    state.regs.eax = claripy.If(buffer == <span class="string">b&#x27;XYMKBKUHNIQYNQXE&#x27;</span>, claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), claripy.BVV(<span class="number">0</span>, <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aim_out</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span><span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">avoid_out</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span><span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find = aim_out, avoid = avoid_out)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223222259816-566746044.png" alt></p>
<h2 id="【例4-2-hooks】10-angr-simprocedures-（对函数本身进行hook避免路径爆炸）"><a href="#【例4-2-hooks】10-angr-simprocedures-（对函数本身进行hook避免路径爆炸）" class="headerlink" title="【例4.2 - hooks】10_angr_simprocedures （对函数本身进行hook避免路径爆炸）"></a>【例4.2 - hooks】10_angr_simprocedures （对函数本身进行hook避免路径爆炸）</h2><p>反编译感觉没什么毛病：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">_BOOL4 __cdecl <span class="title function_">check_equals_ORSDDWXHZURJRBDH</span><span class="params">(<span class="type">int</span> a1, <span class="type">unsigned</span> <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [esp+8h] [ebp-8h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [esp+Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a2; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(_BYTE *)(i + a1) == *(_BYTE *)(i + <span class="number">134529096</span>) )</span><br><span class="line">      ++v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3 == a2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+20h] [ebp-28h]</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">17</span>]; <span class="comment">// [esp+2Bh] [ebp-1Dh] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// [esp+3Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;password, <span class="string">&quot;ORSDDWXHZURJRBDH&quot;</span>, <span class="number">0x10</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%16s&quot;</span>, s);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">    s[i] = complex_function(s[i], <span class="number">18</span> - i);</span><br><span class="line">  <span class="keyword">if</span> ( check_equals_ORSDDWXHZURJRBDH(s, <span class="number">16</span>) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是一看汇编傻眼了：有一堆check函数，代码逻辑相同，但是地址不同，无法对call指令进行hook了。</p>
<p>于是要引入新方法——SimProcedures（模拟程序）。</p>
<p>我们用一个SimProcedure的子类MyCheckEquals模拟check_equals_ORSDDWXHZURJRBDH函数的功能，SimProcedure中的run函数由子类实现，<strong>其接收的参数与C语言中的参数保持一致，返回为对应原函数的返回值。</strong> 根据反编译的信息，<strong>参数分别是输入字符串的首地址和大小，返回值是0或1</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCheckEquals</span>(angr.SimProcedure):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, buffer_addr, length</span>):</span><br><span class="line">        buffer = self.state.memory.load(buffer_addr, length)</span><br><span class="line">        <span class="keyword">return</span> claripy.If(buffer == <span class="string">b&#x27;ORSDDWXHZURJRBDH&#x27;</span>, claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), claripy.BVV(<span class="number">0</span>, <span class="number">32</span>))</span><br></pre></td></tr></table></figure>
<p>那么我们如何让程序不跑原来的check函数而是转而去跑我们自己用python写的run函数呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proj.hook_symbol(symbol_name=<span class="string">&#x27;check_equals_ORSDDWXHZURJRBDH&#x27;</span>, simproc=MyCheckEquals())</span><br></pre></td></tr></table></figure>
<p> 只需要调用hook_symbol函数对程序中名为check_equals_ORSDDWXHZURJRBDH的函数进行hook即可。</p>
<p>后面还是老方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCheckEquals</span>(angr.SimProcedure):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, buffer_addr, length</span>):</span><br><span class="line">        buffer = self.state.memory.load(buffer_addr, length)</span><br><span class="line">        <span class="keyword">return</span> claripy.If(buffer == <span class="string">b&#x27;ORSDDWXHZURJRBDH&#x27;</span>, claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), claripy.BVV(<span class="number">0</span>, <span class="number">32</span>))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">aim_out</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span><span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">avoid_out</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span><span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/home/ep/桌面/10_angr_simprocedures&#x27;</span>)</span><br><span class="line">proj.hook_symbol(symbol_name=<span class="string">&#x27;check_equals_ORSDDWXHZURJRBDH&#x27;</span>, simproc=MyCheckEquals())</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr()</span><br><span class="line">simgr.explore(find = aim_out, avoid = avoid_out)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223222310411-1623340115.png" alt></p>
<h2 id="【例-4-3-hooks】11-angr-sim-scanf-（对多个参数的scanf函数进行hook）"><a href="#【例-4-3-hooks】11-angr-sim-scanf-（对多个参数的scanf函数进行hook）" class="headerlink" title="【例 4.3  - hooks】11_angr_sim_scanf （对多个参数的scanf函数进行hook）"></a>【例 4.3  - hooks】11_angr_sim_scanf （对多个参数的scanf函数进行hook）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+20h] [ebp-28h]</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">20</span>]; <span class="comment">// [esp+28h] [ebp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v7; <span class="comment">// [esp+3Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v7 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  qmemcpy(s, <span class="string">&quot;SUQMKQFX&quot;</span>, <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i )</span><br><span class="line">    s[i] = complex_function(s[i], i);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u %u&quot;</span>, buffer0, buffer1);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(buffer0, s, <span class="number">4u</span>) &amp;&amp; !<span class="built_in">strncmp</span>(buffer1, &amp;s[<span class="number">4</span>], <span class="number">4u</span>) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出scanf函数有多个参数，其实现版本的angr已经可以支持了，这里强行hook一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/home/ep/桌面/11_angr_sim_scanf&#x27;</span>)</span><br><span class="line">proj.hook_symbol(<span class="string">&quot;__isoc99_scanf&quot;</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;scanf&#x27;</span>]()) <span class="comment">#angr在angr/procedures中定义了很多模拟系统函数的SimProcedures，可以通过angr.SIM_PROCEDURES来获得</span></span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(</span><br><span class="line">    find=<span class="keyword">lambda</span> state : <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>),</span><br><span class="line">    avoid=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220223222319657-1109972261.png" alt></p>
<h2 id="【例-5-1-veritesting】12-angr-veritesting-（第三种解决路径爆炸的方法）"><a href="#【例-5-1-veritesting】12-angr-veritesting-（第三种解决路径爆炸的方法）" class="headerlink" title="【例 5.1 - veritesting】12_angr_veritesting （第三种解决路径爆炸的方法）"></a>【例 5.1 - veritesting】12_angr_veritesting （第三种解决路径爆炸的方法）</h2><p> 反编译后发现还是一个路径爆炸的题目：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">complex_function</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( a1 &lt;= <span class="number">64</span> || a1 &gt; <span class="number">90</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (a1 - <span class="number">65</span> + <span class="number">2</span> * a2) % <span class="number">26</span> + <span class="number">65</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// ebx</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp-14h] [ebp-60h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [esp-10h] [ebp-5Ch]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp-Ch] [ebp-58h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [esp-8h] [ebp-54h]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [esp-4h] [ebp-50h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> **v10; <span class="comment">// [esp+0h] [ebp-4Ch]</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [esp+4h] [ebp-48h]</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// [esp+8h] [ebp-44h]</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// [esp+Ch] [ebp-40h]</span></span><br><span class="line">  <span class="type">int</span> v14; <span class="comment">// [esp+10h] [ebp-3Ch]</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// [esp+10h] [ebp-3Ch]</span></span><br><span class="line">  <span class="type">int</span> v16; <span class="comment">// [esp+14h] [ebp-38h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+14h] [ebp-38h]</span></span><br><span class="line">  <span class="type">int</span> v18; <span class="comment">// [esp+18h] [ebp-34h]</span></span><br><span class="line">  _DWORD v19[<span class="number">9</span>]; <span class="comment">// [esp+1Ch] [ebp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v20; <span class="comment">// [esp+40h] [ebp-Ch]</span></span><br><span class="line">  <span class="type">int</span> *p_argc; <span class="comment">// [esp+44h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  p_argc = &amp;argc;</span><br><span class="line">  v10 = argv;</span><br><span class="line">  v20 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">memset</span>((<span class="type">char</span> *)v19 + <span class="number">3</span>, <span class="number">0</span>, <span class="number">0x21</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  ((<span class="type">void</span> (__stdcall *)(<span class="type">const</span> <span class="type">char</span> *, <span class="type">char</span> *, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">const</span> <span class="type">char</span> **, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>, _DWORD))__isoc99_scanf)(</span><br><span class="line">    <span class="string">&quot;%32s&quot;</span>,</span><br><span class="line">    (<span class="type">char</span> *)v19 + <span class="number">3</span>, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v16, v18, v19[<span class="number">0</span>]);</span><br><span class="line">  v15 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = *((<span class="type">char</span> *)v19 + i + <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v3 == complex_function(<span class="number">75</span>, i + <span class="number">93</span>) )</span><br><span class="line">      ++v15;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ( v15 != <span class="number">32</span> || (_BYTE)v20 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Veritesting意为路径归并，具体原理由于链接挂了不得而知，这里只介绍操作，我们只需要在构建simgr的时候添加一个<code>veritesting=True</code>参数即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simgr = proj.factory.simgr(state, veritesting=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>只需要这神奇的一步就可以依靠veritesting原理自动避免路径爆炸。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/home/ep/桌面/12_angr_veritesting&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state, veritesting=<span class="literal">True</span>) <span class="comment">#veritesting值为1，自动避免路径爆炸</span></span><br><span class="line">simgr.explore(</span><br><span class="line">    find=<span class="keyword">lambda</span> state : <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>),</span><br><span class="line">    avoid=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>这种写法与上面的写法是等价的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.use_technique(angr.exploration_techniques.Veritesting())</span><br></pre></td></tr></table></figure>
<p>但是据官方：Versitesting通常与其他exploration_techniques不兼容。</p>
<p>利用veritesting方法避免路径爆炸相对于前两种方法而言比较慢，但是该程序半分钟也能跑完：</p>
<p><img src="/2022/11/04/angr%E5%88%9D%E6%8E%A2/Blog\source\typora-user-images\1688456-20220223223059083-692804482.png" alt></p>
<h2 id="【例-6-1-library】-13-angr-static-binary-（识别静态链接库函数）"><a href="#【例-6-1-library】-13-angr-static-binary-（识别静态链接库函数）" class="headerlink" title="【例 6.1 - library】 13_angr_static_binary  （识别静态链接库函数）"></a>【例 6.1 - library】 13_angr_static_binary  （识别静态链接库函数）</h2><p>以下摘自百度百科：</p>
<blockquote>
<p>静态编译，就是编译器在编译可执行文件的时候，将可执行文件需要调用的对应<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/静态库/8955694">静态库</a>(.a或.lib)中的部分提取出来，链接到可执行文件中去，使可执行文件在运行的时候不依赖于动态链接库。</p>
<p>区分对比</p>
<p>与动态编译的区别</p>
<p>动态编译的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/可执行文件">可执行文件</a>需要附带一个的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/动态链接库/100352">动态链接库</a>。在执行时，需要调用其对应动态链接库中的命令。所以其优点一方面是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省了系统资源。缺点一是哪怕是很简单的程序，只用到了链接库中的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/运行库">运行库</a>，则用动态编译的可执行文件就不能运行。</p>
<p>静态编译就是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/编译器">编译器</a>在编译可执行文件的时候，将可执行文件需要调用的对应<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/静态库/8955694">静态库</a>(.a或.lib)中的部分提取出来，链接到可执行文件中去，使可执行文件在运行的时候不依赖于动态链接库。所以其优缺点与<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/动态编译">动态编译</a>的可执行文件正好互补。</p>
</blockquote>
<p>就比如这个题,反编译后发现有一堆函数:</p>
<p><img src="/2022/11/04/angr%E5%88%9D%E6%8E%A2/Blog\source\typora-user-images\1688456-20220223224509899-1328777193.png" alt></p>
<p>虽然反编译的main函数和【例 1.1】是一样的，由于此时是静态库，angr无法从动态库种获取链接，因此用原来的脚本无法运行，因此需要我们手动hook：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/home/ep/桌面/13_angr_static_binary&#x27;</span>)</span><br><span class="line"></span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;printf&#x27;</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;printf&#x27;</span>]())</span><br><span class="line"><span class="comment">#也可以写成 proj.hook(0x804ED40, angr.SIM_PROCEDURES[&#x27;libc&#x27;][&#x27;printf&#x27;]())，这种就是用地址进行hook，但是在函数调用较多的情况下还是直接用函数名比较方便</span></span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;__isoc99_scanf&#x27;</span>,angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;scanf&#x27;</span>]())</span><br><span class="line"><span class="comment">#__libc_start_main函数会在入口函数_start里被调用，主要是完成一些程序的初始化操作以及main函数的调用，这个函数也把它hook掉</span></span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;strcmp&#x27;</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;strcmp&#x27;</span>]())</span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;puts&#x27;</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;puts&#x27;</span>]())</span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;__libc_start_main&#x27;</span>,angr.SIM_PROCEDURES[<span class="string">&#x27;glibc&#x27;</span>][<span class="string">&#x27;__libc_start_main&#x27;</span>]())</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(</span><br><span class="line">    find=<span class="keyword">lambda</span> state : <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>),</span><br><span class="line">    avoid=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/2022/11/04/angr%E5%88%9D%E6%8E%A2/Blog\source\typora-user-images\1688456-20220223225416756-2021800863-1645628081978.png" alt></p>
<h2 id="【例-6-2-library】14-angr-shared-library-（-对动态链接库中单个的函数进行符号执行-）"><a href="#【例-6-2-library】14-angr-shared-library-（-对动态链接库中单个的函数进行符号执行-）" class="headerlink" title="【例 6.2 - library】14_angr_shared_library （ 对动态链接库中单个的函数进行符号执行 ）"></a>【例 6.2 - library】14_angr_shared_library （ 对动态链接库中单个的函数进行符号执行 ）</h2><p>反编译发现一个叫<strong>validate</strong>的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">16</span>]; <span class="comment">// [esp+1Ch] [ebp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// [esp+2Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%8s&quot;</span>, s);</span><br><span class="line">  <span class="keyword">if</span> ( validate(s, <span class="number">8</span>) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本题除了<strong>14_angr_shared_library</strong> 这个文件外还有一个<strong>lib14_angr_shared_library.so</strong>，而<strong>validate</strong>函数就是从这个外部库文件中导入的，我们对这个库文件反编译可以查看<strong>validate</strong>的源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">_BOOL4 __cdecl <span class="title function_">validate</span><span class="params">(<span class="type">char</span> *s1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v3; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">char</span> s2[<span class="number">20</span>]; <span class="comment">// [esp+4h] [ebp-24h] BYREF</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [esp+18h] [ebp-10h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 &lt;= <span class="number">7</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">19</span>; ++i )</span><br><span class="line">    s2[i] = <span class="number">0</span>;</span><br><span class="line">  qmemcpy(s2, <span class="string">&quot;PVBLVTFT&quot;</span>, <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">7</span>; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = &amp;s1[j];</span><br><span class="line">    *v3 = complex_function(s1[j], j);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(s1, s2) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态链接库都是地址无关的可执行文件（position-independent executable，PIE），若不手动指定PIE的基质，angr会将符号执行的基址指定为默认的<strong>0x400000</strong>，当然也可以自行指定基址，方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">base = <span class="number">0x400000</span></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/home/ep/桌面/lib14_angr_shared_library.so&#x27;</span>, load_options=&#123;</span><br><span class="line">    <span class="string">&#x27;main_opts&#x27;</span> : &#123;</span><br><span class="line">        <span class="string">&#x27;base_addr&#x27;</span> : base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>接下来找到程序的入口和出口：</p>
<p><img src="/2022/11/04/angr%E5%88%9D%E6%8E%A2/Blog\source\typora-user-images\1688456-20220224001258296-1366064308.png" alt></p>
<p>可以看出validate函数的地址是<strong>0x6D7</strong>，也就是相对于基准地址偏移了<strong>0x6D7</strong>。</p>
<p>而程序结束是<code>return strcmp(s1, s2) == 0;</code>条件句，以retn结束，返回值保存在寄存器eax中，我们需要得到的是<strong>eax  == 1</strong>这个条件。</p>
<p><img src="https://img2022.cnblogs.com/blog/1688456/202202/1688456-20220224004015805-839289432.png" alt></p>
<p>注释版脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">base = <span class="number">0x400000</span>  <span class="comment"># 设置动态链接库的基址，不唯一</span></span><br><span class="line">proj = angr.Project(</span><br><span class="line">    <span class="string">&quot;./lib14_angr_shared_library.so&quot;</span>, </span><br><span class="line">    load_options=&#123;</span><br><span class="line">        <span class="string">&quot;main_opts&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;custom_base_addr&quot;</span>: base</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">buffer = claripy.BVV(<span class="number">0</span>, <span class="number">32</span>) <span class="comment"># 新建一个初始值为0（任意值即可）的32位BitVector</span></span><br><span class="line">validate_addr = base + <span class="number">0x6d7</span> <span class="comment"># 函数validate的地址，相对于base偏移了0x6D7</span></span><br><span class="line"></span><br><span class="line">state = proj.factory.call_state(validate_addr, buffer, <span class="number">8</span>) </span><br><span class="line"><span class="comment"># 通过call_state(func_addr,*argv,length) 创建一个函数调用的初始状态，由于是8位字符比较，因此length=8，这个8也可以用一个BV表示：state = proj.factory.call_state(validate_addr, buffer, claripy.BVV(8, 32))</span></span><br><span class="line"></span><br><span class="line">flag = claripy.BVS(<span class="string">&quot;flag&quot;</span>, <span class="number">8</span>*<span class="number">8</span>) </span><br><span class="line">state.memory.store(buffer,flag) <span class="comment">#将一个长度为8*8的字符串符号化注入刚才初始化的buffer</span></span><br><span class="line"></span><br><span class="line">aim_addr = base + <span class="number">0x783</span>  <span class="comment"># validate返回地址</span></span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find = aim_addr)</span><br><span class="line"></span><br><span class="line">sol = simgr.found[<span class="number">0</span>] <span class="comment">#得到strcmp的返回值</span></span><br><span class="line">sol.add_constraints(sol.regs.eax != <span class="number">0</span>) <span class="comment"># 添加配对约束</span></span><br><span class="line"><span class="built_in">print</span>(sol.solver.<span class="built_in">eval</span>(flag, cast_to=<span class="built_in">bytes</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/2022/11/04/angr%E5%88%9D%E6%8E%A2/Blog\source\typora-user-images\1688456-20220224003733871-573393736.png" alt></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://example.com">EPs1l0h</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://example.com/2022/11/04/angr%E5%88%9D%E6%8E%A2/">https://example.com/2022/11/04/angr%E5%88%9D%E6%8E%A2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://example.com" target="_blank">EPs1l0h's Castle</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover1.jpg?raw=true" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/04/TSCTF-J2022/"><img class="prev-cover" src="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover7.jpg?raw=true" onerror="onerror=null;src='/img/404.gif'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">TSCTF-J 2022 Reverse (Official?) Write Up</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/02/idapro%E5%BF%AB%E6%8D%B7%E9%94%AE/"><img class="next-cover" src="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover6.jpg?raw=true" onerror="onerror=null;src='/img/404.gif'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">idapro快捷键</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">EPs1l0h</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/EPs1l0h"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Spears shall be shaken! Shields shall be splintered! A sword day! A red day! Ere the sun rises!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%A2%8E%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">一些碎碎念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#angr%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">angr介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C"><span class="toc-number">2.1.</span> <span class="toc-text">符号执行</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#virtualenvwrapper"><span class="toc-number">3.</span> <span class="toc-text">virtualenvwrapper</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85virtualenvwrapper"><span class="toc-number">3.1.</span> <span class="toc-text">安装virtualenvwrapper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#virtualenvwrapper%E7%9A%84%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">3.2.</span> <span class="toc-text">virtualenvwrapper的操作命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%88%9D%E6%8E%A2"><span class="toc-number">4.</span> <span class="toc-text">使用初探</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E4%BE%8B-1-1-explore%E3%80%9100-angr-find-%EF%BC%88explore%E7%9A%84find%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">【例 1.1 - explore】00_angr_find （explore的find方法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E4%BE%8B-1-2-explore%E3%80%9101-angr-avoid-%EF%BC%88explore%E7%9A%84avoid%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">【例 1.2 - explore】01_angr_avoid （explore的avoid方法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E4%BE%8B-1-3-explore%E3%80%9102-angr-find-condition-%EF%BC%88%E4%BB%A5%E7%89%B9%E5%AE%9A%E8%BE%93%E5%87%BA%E4%B8%BA%E5%87%BA%E5%8F%A3%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">【例 1.3 - explore】02_angr_find_condition （以特定输出为出口）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E4%BE%8B-2-1-symbolic%E3%80%9103-angr-symbolic-registers-%EF%BC%88%E5%AF%B9%E5%AF%84%E5%AD%98%E5%99%A8%E7%AC%A6%E5%8F%B7%E5%8C%96%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">【例 2.1 - symbolic】03_angr_symbolic_registers （对寄存器符号化）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E4%BE%8B-2-2-symbolic%E3%80%9104-angr-symbolic-stack-%EF%BC%88%E5%AF%B9%E6%A0%88%E7%A9%BA%E9%97%B4%E5%86%85%E7%9A%84%E6%95%B0%E6%8D%AE%E7%AC%A6%E5%8F%B7%E5%8C%96%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">【例 2.2 - symbolic】04_angr_symbolic_stack （对栈空间内的数据符号化）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E4%BE%8B-2-3-symbolic%E3%80%9105-angr-symbolic-memory-%EF%BC%88%E5%AF%B9%E5%86%85%E5%AD%98%E7%AC%A6%E5%8F%B7%E5%8C%96%EF%BC%89"><span class="toc-number">4.6.</span> <span class="toc-text">【例 2.3 - symbolic】05_angr_symbolic_memory  （对内存符号化）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E4%BE%8B-2-4-symbolic%E3%80%9106-angr-symbolic-dynamic-memory-%EF%BC%88%E5%AF%B9%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9A%84%E7%AC%A6%E5%8F%B7%E5%8C%96%EF%BC%89"><span class="toc-number">4.7.</span> <span class="toc-text">【例 2.4 - symbolic】06_angr_symbolic_dynamic_memory （对动态内存的符号化）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E4%BE%8B-2-5-symbolic%E3%80%9107-angr-symbolic-file-%EF%BC%88%E5%AF%B9%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E7%AC%A6%E5%8F%B7%E5%8C%96%EF%BC%89"><span class="toc-number">4.8.</span> <span class="toc-text">【例 2.5 - symbolic】07_angr_symbolic_file （对文件内容符号化）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E4%BE%8B-3-1-constraints%E3%80%9108-angr-constraints-%EF%BC%88%E6%89%8B%E5%8A%A8%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F%E9%81%BF%E5%85%8D%E8%B7%AF%E5%BE%84%E7%88%86%E7%82%B8%EF%BC%89"><span class="toc-number">4.9.</span> <span class="toc-text">【例 3.1 - constraints】08_angr_constraints （手动添加约束避免路径爆炸）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E4%BE%8B-4-1-hooks%E3%80%9109-angr-hooks-%EF%BC%88%E5%AF%B9call%E6%8C%87%E4%BB%A4%E8%BF%9B%E8%A1%8Chook%E9%81%BF%E5%85%8D%E8%B7%AF%E5%BE%84%E7%88%86%E7%82%B8%EF%BC%89"><span class="toc-number">4.10.</span> <span class="toc-text">【例 4.1 - hooks】09_angr_hooks （对call指令进行hook避免路径爆炸）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E4%BE%8B4-2-hooks%E3%80%9110-angr-simprocedures-%EF%BC%88%E5%AF%B9%E5%87%BD%E6%95%B0%E6%9C%AC%E8%BA%AB%E8%BF%9B%E8%A1%8Chook%E9%81%BF%E5%85%8D%E8%B7%AF%E5%BE%84%E7%88%86%E7%82%B8%EF%BC%89"><span class="toc-number">4.11.</span> <span class="toc-text">【例4.2 - hooks】10_angr_simprocedures （对函数本身进行hook避免路径爆炸）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E4%BE%8B-4-3-hooks%E3%80%9111-angr-sim-scanf-%EF%BC%88%E5%AF%B9%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84scanf%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8Chook%EF%BC%89"><span class="toc-number">4.12.</span> <span class="toc-text">【例 4.3  - hooks】11_angr_sim_scanf （对多个参数的scanf函数进行hook）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E4%BE%8B-5-1-veritesting%E3%80%9112-angr-veritesting-%EF%BC%88%E7%AC%AC%E4%B8%89%E7%A7%8D%E8%A7%A3%E5%86%B3%E8%B7%AF%E5%BE%84%E7%88%86%E7%82%B8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">4.13.</span> <span class="toc-text">【例 5.1 - veritesting】12_angr_veritesting （第三种解决路径爆炸的方法）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E4%BE%8B-6-1-library%E3%80%91-13-angr-static-binary-%EF%BC%88%E8%AF%86%E5%88%AB%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">4.14.</span> <span class="toc-text">【例 6.1 - library】 13_angr_static_binary  （识别静态链接库函数）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%90%E4%BE%8B-6-2-library%E3%80%9114-angr-shared-library-%EF%BC%88-%E5%AF%B9%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E4%B8%AD%E5%8D%95%E4%B8%AA%E7%9A%84%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C-%EF%BC%89"><span class="toc-number">4.15.</span> <span class="toc-text">【例 6.2 - library】14_angr_shared_library （ 对动态链接库中单个的函数进行符号执行 ）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/22/vnctf2023-%E5%A4%8D%E7%8E%B0/" title="vnctf2023 - 复现"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.gif'" alt="vnctf2023 - 复现"/></a><div class="content"><a class="title" href="/2023/02/22/vnctf2023-%E5%A4%8D%E7%8E%B0/" title="vnctf2023 - 复现">vnctf2023 - 复现</a><time datetime="2023-02-22T11:16:26.000Z" title="发表于 2023-02-22 19:16:26">2023-02-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/17/hgame2023wp/" title="HGAME 2023 week3 &amp; week4 writeup"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.gif'" alt="HGAME 2023 week3 &amp; week4 writeup"/></a><div class="content"><a class="title" href="/2023/02/17/hgame2023wp/" title="HGAME 2023 week3 &amp; week4 writeup">HGAME 2023 week3 &amp; week4 writeup</a><time datetime="2023-02-17T09:08:23.000Z" title="发表于 2023-02-17 17:08:23">2023-02-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/06/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91%E5%88%9D%E8%B5%9B2023/" title="西湖论剑初赛2023 - re复现"><img src="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover3.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.gif'" alt="西湖论剑初赛2023 - re复现"/></a><div class="content"><a class="title" href="/2023/02/06/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91%E5%88%9D%E8%B5%9B2023/" title="西湖论剑初赛2023 - re复现">西湖论剑初赛2023 - re复现</a><time datetime="2023-02-06T09:49:06.000Z" title="发表于 2023-02-06 17:49:06">2023-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/18/unicorn%E5%88%9D%E6%8E%A2/" title="unicorn模拟执行初探"><img src="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover1.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.gif'" alt="unicorn模拟执行初探"/></a><div class="content"><a class="title" href="/2023/01/18/unicorn%E5%88%9D%E6%8E%A2/" title="unicorn模拟执行初探">unicorn模拟执行初探</a><time datetime="2023-01-18T14:54:05.000Z" title="发表于 2023-01-18 22:54:05">2023-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/12/%E8%AE%B0%E4%B8%80%E6%AC%A1TEC-8%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6patch/" title="记一次TEC-8仿真软件patch"><img src="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover5.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.gif'" alt="记一次TEC-8仿真软件patch"/></a><div class="content"><a class="title" href="/2022/12/12/%E8%AE%B0%E4%B8%80%E6%AC%A1TEC-8%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6patch/" title="记一次TEC-8仿真软件patch">记一次TEC-8仿真软件patch</a><time datetime="2022-12-12T06:39:19.000Z" title="发表于 2022-12-12 14:39:19">2022-12-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover1.jpg?raw=true')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By EPs1l0h</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://example.com/2022/11/04/angr%E5%88%9D%E6%8E%A2/'
    this.page.identifier = '/2022/11/04/angr%E5%88%9D%E6%8E%A2/'
    this.page.title = 'angr初探'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Disqus' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>