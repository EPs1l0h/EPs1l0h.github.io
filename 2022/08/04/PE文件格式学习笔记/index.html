<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>PE文件格式学习笔记 | EPs1l0h's Castle</title><meta name="author" content="EPs1l0h"><meta name="copyright" content="EPs1l0h"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="感觉只学手操不学基础知识还是不行，趁着暑假赶紧补一补， 跟着这篇学的  。 从一次PE编辑实现弹窗开始堆理论知识之前先搞一波实操：在一个exe程序启动之前实现一个弹窗功能。 添加区段这里就用线程的LordPE来实现吧，我们先拷贝一份_LordPE_fix - 副本，打开后显示出这样的界面  这便是该程序的启动界面，我们要做的就是在这个界面之前添加一个弹窗。 我们用LordPE打开之前拷贝的副本（没">
<meta property="og:type" content="article">
<meta property="og:title" content="PE文件格式学习笔记">
<meta property="og:url" content="https://example.com/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="EPs1l0h&#39;s Castle">
<meta property="og:description" content="感觉只学手操不学基础知识还是不行，趁着暑假赶紧补一补， 跟着这篇学的  。 从一次PE编辑实现弹窗开始堆理论知识之前先搞一波实操：在一个exe程序启动之前实现一个弹窗功能。 添加区段这里就用线程的LordPE来实现吧，我们先拷贝一份_LordPE_fix - 副本，打开后显示出这样的界面  这便是该程序的启动界面，我们要做的就是在这个界面之前添加一个弹窗。 我们用LordPE打开之前拷贝的副本（没">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover1.jpg?raw=true">
<meta property="article:published_time" content="2022-08-04T07:18:37.000Z">
<meta property="article:modified_time" content="2022-11-17T03:25:10.000Z">
<meta property="article:author" content="EPs1l0h">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover1.jpg?raw=true"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://example.com/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PE文件格式学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-17 11:25:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover1.jpg?raw=true')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">EPs1l0h's Castle</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">PE文件格式学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-04T07:18:37.000Z" title="发表于 2022-08-04 15:18:37">2022-08-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-17T03:25:10.000Z" title="更新于 2022-11-17 11:25:10">2022-11-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="PE文件格式学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>感觉只学手操不学基础知识还是不行，趁着暑假赶紧补一补， <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gv411W7om?p=2&amp;vd_source=86ffb923c9f49c76391f3e642ff2c615">跟着这篇学的</a>  。</p>
<h1 id="从一次PE编辑实现弹窗开始"><a href="#从一次PE编辑实现弹窗开始" class="headerlink" title="从一次PE编辑实现弹窗开始"></a>从一次PE编辑实现弹窗开始</h1><p>堆理论知识之前先搞一波实操：在一个exe程序启动之前实现一个弹窗功能。</p>
<h2 id="添加区段"><a href="#添加区段" class="headerlink" title="添加区段"></a>添加区段</h2><p>这里就用线程的LordPE来实现吧，我们先拷贝一份<code>_LordPE_fix - 副本</code>，打开后显示出这样的界面</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221300828-1542517542.png" alt></p>
<p>这便是该程序的启动界面，我们要做的就是在这个界面之前添加一个弹窗。</p>
<p>我们用LordPE打开之前拷贝的副本（没错，我改我自己），显示的便是拷贝文件的一些基本信息</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221315313-882761451.png" alt></p>
<p>重点关注以下信息：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>区段数目</strong></th>
<th><strong>NumberOfSections</strong></th>
<th><strong>0004</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>入口点</strong></td>
<td><strong>EntryPoint</strong></td>
<td><strong>0x00004340</strong></td>
</tr>
<tr>
<td><strong>镜像基址</strong></td>
<td><strong>ImageBase</strong></td>
<td><strong>0x00040000</strong></td>
</tr>
<tr>
<td><strong>镜像大小</strong></td>
<td><strong>SizeOfImages</strong></td>
<td><strong>0x00036000</strong></td>
</tr>
</tbody>
</table>
</div>
<p>点击区段，显示出区段表，正好有4项</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221327027-926142441.png" alt></p>
<p>名称后面分别是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>VOffset</th>
<th>VSize</th>
<th>ROffset</th>
<th>Rsize</th>
<th>Flags</th>
</tr>
</thead>
<tbody>
<tr>
<td>映射入内存后的虚拟地址</td>
<td>映射入内存后的虚拟地址长度</td>
<td>文件中的位置</td>
<td>文件中的长度</td>
<td>区段属性</td>
</tr>
</tbody>
</table>
</div>
<p>右击最下面的区段后点击添加区段，发现多了一个NewSec区段。</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221334552-2108901385.png" alt></p>
<p>之后右击修改新区段在虚拟和物理磁盘中的大小以及标志，把不需要的取消勾选。</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221339247-1489511248.png" alt></p>
<p>修改后的区段表如下：</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221349161-1591627388.png" alt></p>
<p>我们发现区段数已经增加了，我们单机保存即可，虽然添加了一个区段，但是文件的实际大小却没有改变</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221355307-1470527428.png" alt></p>
<p>我们尝试运行副本</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221402870-1750258736.png" alt></p>
<p>发现无法运行，这<strong>是因为我们添加了一个区段后，这是因为我们刚才只给了该文件一个区段，但是却没有对应的文件，因此会出现报错，无法被windows系统加载</strong>，于是我们选择打开16进制编辑器。</p>
<h2 id="用16进制编辑器修改文件"><a href="#用16进制编辑器修改文件" class="headerlink" title="用16进制编辑器修改文件"></a>用16进制编辑器修改文件</h2><p>这里选择HXD_Hex_32来完成。</p>
<p>用编辑器打开后发现末尾地址是<code>0x32FFF</code></p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221411360-1536647327.png" alt></p>
<p>通过简单计算，<script type="math/tex">0x32FFF + 1 = 0x33000</script> 正好是我们添加的区段在文件中的地址起始点，我们在末尾添加512个字节（用16进制00填充），发现文件变大了</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221417163-1288940291.png" alt></p>
<p>此时再次打开副本发现可以打开。</p>
<blockquote>
<p>TIPS：新版的windows可能改过PE文件加载过程，如果win版本较低的话这里可能双击仍然无法正常运行，这时可以用LordPE继续修改，把镜像基址0x00036000加0x1000变成0x00037000，win10下他自动改好了 </p>
</blockquote>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221423868-2069735920.png" alt></p>
<p>修改汇编添加弹出对话框功能</p>
<p>拖入OD发现停在了EntryPoint处</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221428993-1180499074.png" alt></p>
<p>此时对应的是虚拟地址，该地址的计算方法为：<strong>虚拟地址 = 镜像基址 +入口点</strong></p>
<p>由于我们要实现的功能是在程序启动前实现弹窗，于是我们考虑把入口点设置为之前添加的NewSec区段映射入内存后的起始地址。</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221436624-67015682.png" alt></p>
<p>再次拖入OD，发现入口点发生改变，变成了00436000。</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221442861-300905365.png" alt></p>
<p>按Ctrl+G定位到地址00436020，选中部分字节后按空格编辑，选择ASCII码直接输入字符串<code>HelloWorld!!</code>，发现上方的汇编语言也跟着改变了。</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221449746-461007435.png" alt></p>
<p><strong>这是因为OD把输入的HelloWorld!! 和 Hello 两串字符当成了汇编代码进行显示，这当然没办法执行。</strong></p>
<p>之后我们从入口点00436000开始插入以下汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push 0</span><br><span class="line">push 00436030</span><br><span class="line">push 00436020</span><br><span class="line">push 0</span><br><span class="line">call MessageBoxA</span><br></pre></td></tr></table></figure>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221500625-1851405553.png" alt></p>
<p>发现录入汇编后，在注释的位置便可以自动解析出对应地址我们之前输入的ASCII码。</p>
<p>之后我们右击-&gt;复制到可执行文件-&gt;选择-&gt;保存文件并覆盖原文件，我们就把改好的汇编代码添加到了原来的LordPE副本文件。此时我们点击运行该文件，发现出现了弹窗</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221508307-175233824.png" alt></p>
<p>但是PE文件本体却没有执行，这是因为我们修改了入口点，并且添加的汇编代码没有跳转到原来的代码起始点的指令，因此在弹窗之后原来的文件是无法打开的。</p>
<p>于是我们在此修改汇编，在弹窗指令后加入一个跳转指令</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221513937-1396635640.png" alt></p>
<p>我们对其进行调试，发现在执行call语句弹窗后，我们点击确定执行jmp跳转指令，程序便运行到之前的入口点处了。</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221520842-406444057.png" alt></p>
<p>此时我们再次覆盖文件后，发现程序便可以再弹窗后正常打开了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本次操作成功实现了在一个可执行文件之前添加一个弹窗并且成功跳转到原入口点处的功能。</p>
<p>这种应用有很多实际意义，比如</p>
<ol>
<li>病毒技术，反病毒技术，反反病毒（免杀）技术</li>
<li>软件保护技术，如加壳、脱壳技术</li>
</ol>
<p>如果我们刚刚在本体前加的不是弹对话框，而是其他的一些文件操作函数，比如遍历磁盘并删除文件，这就是一款具有破坏性的病毒了，对于反病毒技术，如何分离病毒代码与宿主程序，或者修复被破坏的程序，这也需要用到PE文件结构的知识。</p>
<h1 id="PE文件结构概述"><a href="#PE文件结构概述" class="headerlink" title="PE文件结构概述"></a>PE文件结构概述</h1><p>PE文件格式是Portable Executable的缩写，即可移植的执行体。windows操作系统下，所有的可执行文件都是PE格式，如exe文件，dll文件，sys文件，ocx文件等。</p>
<p>PE结构不是一个单纯的结构，一个PE文件由若干个结构集合所构成，不同的结构有不同的用处。</p>
<p>PE文件格式是一种对文件组织管理的方式 </p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221530109-1083282666.png" alt></p>
<p>这里的数据指的是广义上的数据，因为无论是代码，数据还是资源，其实初始状态都是数据。</p>
<h2 id="一个栗子（用RadASM编写一个简单程序）"><a href="#一个栗子（用RadASM编写一个简单程序）" class="headerlink" title="一个栗子（用RadASM编写一个简单程序）"></a>一个栗子（用RadASM编写一个简单程序）</h2><p>打开RadASM创建工程，直接编写汇编代码即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">	<span class="number">.386</span>  <span class="comment">//用到的汇编指令的指令集是.386</span></span><br><span class="line">	.model flat, stdcall <span class="comment">//flat表示使用的是内存的平坦模式，stdcall是函数调用的一种方式</span></span><br><span class="line">	option casemap:none <span class="comment">//casemap:none就是不区分大小写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用头文件和链接库</span></span><br><span class="line">include windows.inc <span class="comment">//一些常量</span></span><br><span class="line">include kernel32.inc <span class="comment">//kernel32.dll中的一些系统函数</span></span><br><span class="line">include user32.inc <span class="comment">//user32.dll的一些函数</span></span><br><span class="line">includelib kernel32.lib</span><br><span class="line">includelib user32.lib</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义字符串</span></span><br><span class="line">	.data</span><br><span class="line">szCaption   db  <span class="string">&#x27;hello&#x27;</span>, <span class="number">0</span> <span class="comment">//db是字节的意思，定义hello字符串，汇编中win32用,&#x27;\0&#x27;进行结尾</span></span><br><span class="line">szText	    db 	<span class="string">&#x27;hello world!&#x27;</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码部分</span></span><br><span class="line">	.code</span><br><span class="line">start: <span class="comment">//代码从标号开始执行，下面的end start也就是说标号是start</span></span><br><span class="line">	push <span class="number">0</span></span><br><span class="line">	lea eax, szCaption</span><br><span class="line">	push eax</span><br><span class="line">	lea eax, szText</span><br><span class="line">	push eax</span><br><span class="line">	push <span class="number">0</span></span><br><span class="line">	call MessageBox <span class="comment">//一段简单的弹窗代码，弹出文本szCaption和szText</span></span><br><span class="line">	push <span class="number">0</span></span><br><span class="line">	call ExitProcess</span><br><span class="line">	end start</span><br></pre></td></tr></table></figure>
<p>编译后连接，工程文件夹中出现demo.exe文件，执行后就是我们刚才编写的弹窗程序</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221541032-754532409.png" alt></p>
<h2 id="在WinHex中对比可执行文件在文件和内存中的差距"><a href="#在WinHex中对比可执行文件在文件和内存中的差距" class="headerlink" title="在WinHex中对比可执行文件在文件和内存中的差距"></a>在WinHex中对比可执行文件在文件和内存中的差距</h2><p>用winhex打开demo.exe，之后执行demo.exe，在工具栏中打开RAM，找到demo#6164下的demo.exe打开</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221546952-1370928245.png" alt></p>
<p>分别为文件中和内存中的demo.exe：<img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221559649-866073003.png" alt></p>
<p>对比发现</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221617948-2063911667.png" alt></p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221624490-108234360.png" alt></p>
<p>文件中的demo.exe是从00000000开始的，但是内存中的demo.exe却是从00400000开始的。</p>
<p>此外</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221629624-1694442119.png" alt></p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221634706-595941799.png" alt></p>
<p>190到220这一段数据是可以对应上的，但同时也发现</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221642113-1016278815.png" alt></p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221653436-1847399153.png" alt></p>
<p>文件中的600开始和内存中的2000开始发现调用的dll是一样的，可以对应上，但是前面的部分数据却对应不上。</p>
<h2 id="用PEView查看可执行文件的结构"><a href="#用PEView查看可执行文件的结构" class="headerlink" title="用PEView查看可执行文件的结构"></a>用PEView查看可执行文件的结构</h2><p>用PEView打开demo.exe</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221659868-833549185.png" alt></p>
<p>右边显示的和之前在winhex中的一样，分别是偏移Offset，数据Raw Data和对应的值Value(以字符的方式显示，如果无法解析则用<code>.</code>代替)</p>
<p>然后我们点击第一个IMAGE_DOS_HEADER</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221706655-1827748097.png" alt></p>
<p>注意箭头的位置，我们发现之前整个程序从00000000开始的16进制字节分别是4D 5A，但是这里却倒过来了变成了5A4D，这个玩意叫做字节序。</p>
<p>此外，signature的Data 00004550我们找到文件中相对应的位置000000B0，发现是50，45<img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221731144-1852679152.png" alt><br>也是倒序的，这个玩意也是因为字节序导致的。</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221752080-1182754373.png" alt></p>
<p>再看左边：</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221757172-1407229979.png" alt></p>
<ul>
<li><p>IMAGE_DOS_HEADER：dos头</p>
</li>
<li><p>MS-DOS Stub Program：DOS存根</p>
</li>
<li><p>Signature：PE文件的标识</p>
</li>
<li><p>IMAGE_FILE_HEADER：文件头</p>
</li>
<li><p>IMAGE_OPTIONAL_HEADER：可选头（但不是可以不选的那种，是必须有的，只是其中某些东西只需要占位，不需要有具体数据）</p>
</li>
<li><p>IMAGE_SECTION_HEADER：节区，给出了三种数据在文件和在内存中的位置</p>
<ul>
<li>.text：代码</li>
<li>.rdata: 只读数据</li>
<li>.data：数据</li>
</ul>
</li>
<li><p>SECTION：有三个，分别为.text，.rdata，.data，是真正的数据</p>
</li>
</ul>
<p>文件中的数据不会变化，但是在映射到内存中后一些相对位置就变了</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710221954576-578268063.png" alt></p>
<h1 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h1><p>DOS头是PE文件结构的第一个头，用来保持对DOS系统的兼容，并且用于定位真正的PE头。</p>
<p>因为DOS操作系统已经不存在了，DOS头现在的作用也就是保持一个兼容给出一个提示，没什么太大作用。</p>
<p>DOS头在winnt.h头文件中的定义如下（该文件头大小为40h，64d）</p>
<p>我们关注的主要是两个属性：e_magic 和 e_lfanew</p>
<blockquote>
<p>TIPS:WORD是双字节，LONG是4字节</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span>		</span><br><span class="line">	WORD	e_magic;						 <span class="comment">//00h EXE标志MZ，MZ是一个人名的缩写</span></span><br><span class="line">	WORD	e_cblp;							 <span class="comment">//02h 最后（部分)页中的字节数</span></span><br><span class="line">	WORD	e_cp;							 <span class="comment">//04h 文件中的全部和部分页数</span></span><br><span class="line">	WORD	e_crlc;							 <span class="comment">//06h 重定位表中的指针数</span></span><br><span class="line">	WORD	e_cparhdr;						 <span class="comment">//08h 头部尺寸，以段落为单位</span></span><br><span class="line">	WORD	e_minalloc;						 <span class="comment">//0Ah 所需的最小附加段</span></span><br><span class="line">	WORD	e_maxalloc;						 <span class="comment">//0Ch 所需的最大附加段</span></span><br><span class="line">	WORD	e_ss;							 <span class="comment">//0Eh 初始的SS值(相对偏移量)</span></span><br><span class="line">	WORD	e_sp;							 <span class="comment">//10h 初始的SP值</span></span><br><span class="line">	WORD	e_csum;							 <span class="comment">//12h 校验和</span></span><br><span class="line">	WORD	e_ip;							 <span class="comment">//14h 初始的IP值</span></span><br><span class="line">	WORD	e_cs;							 <span class="comment">//16h 初始的CS值</span></span><br><span class="line">	WORD	e_lfarlc;						 <span class="comment">//18h 重定位表的字节偏移量</span></span><br><span class="line">	WORD	e_ovno;							 <span class="comment">//1Ah 覆盖号</span></span><br><span class="line">	WORD	e_res[<span class="number">4</span>];						 <span class="comment">//1Ch 保留字</span></span><br><span class="line">	WORD	e_oemid;						 <span class="comment">//24h EM标识符（相对e_oeminfo )</span></span><br><span class="line">	WORD	e_oeminfo;						 <span class="comment">//26h OEM信息; e_oemid specific</span></span><br><span class="line">	WORD	e_res2[<span class="number">10</span>];						 <span class="comment">//28h 保留字</span></span><br><span class="line">	LONG	e_lfanew;						 <span class="comment">//3Ch PE头相对于文件的偏移地址</span></span><br><span class="line">&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_DOS_SIGNATURE 0x4D5A <span class="comment">//MZ</span></span></span><br></pre></td></tr></table></figure>
<h2 id="判断一个文件是否为PE文件"><a href="#判断一个文件是否为PE文件" class="headerlink" title="判断一个文件是否为PE文件"></a>判断一个文件是否为PE文件</h2><p>用16进制编辑器打开一个文件，就那之前编写的demo.exe来做例子吧。</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222030407-1599153136.png" alt></p>
<p>由于文件头大小为40h，我们只关注前4行：</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222040944-1317060087.png" alt></p>
<p>之前的DOS头的定义，我们知道，demo.exe的e_magic（前两个字节）是4D5A，即对应文本MZ，此外我们关注的</p>
<p>e_lfanew是B0 00 00 00 ，但是由于这玩意是小端序存储，所以PE头相对于文件的实际偏移为00 00 00 B0，因此我们找到000000B0处，</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222050370-1183981712.png" alt></p>
<p>发现从这里开始正好是50 45 00 00对应PE..，而00000040到000000B0之间的这一段数据是没有用的。</p>
<p>因此判断一个文件是否为PE文件的步骤为</p>
<ol>
<li>观察其前2字节是否为4D 5A（MZ）</li>
<li>找到e_lfanew（3C到3F的小端序）</li>
<li>根据e_lfanew找到地址，观察其前4字节是否为PE00</li>
</ol>
<p>找到了PE的话一般都是PE文件了</p>
<blockquote>
<p>不是所有MZ开头的都是可执行文件，但是所有可执行文件都是MZ开头</p>
<p>intel架构的cpu存储数据都是小端序，大端序存储一般在其他cpu架构或者网络传输数据时使用 </p>
<p>网络上传输数据一般都是大尾方式</p>
</blockquote>
<h2 id="写个程序计算DOS-HEADER大小"><a href="#写个程序计算DOS-HEADER大小" class="headerlink" title="写个程序计算DOS_HEADER大小"></a>写个程序计算DOS_HEADER大小</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %x\r\n&quot;</span>, <span class="built_in">sizeof</span>(IMAGE_DOS_HEADER), <span class="built_in">sizeof</span>(IMAGE_DOS_HEADER));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222101860-1123364674.png" alt></p>
<p>即base10下为64，base16下为40。</p>
<h2 id="一个简单实验"><a href="#一个简单实验" class="headerlink" title="一个简单实验"></a>一个简单实验</h2><p>为了证明之前所说的在00000040到000000B0之间的数据是没用的，可以用16进制编辑器把这一段数据填充为00，然后尝试打开demo.exe。</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222108452-404357138.png" alt></p>
<p>填充后重新打开demo.exe，发现依然可以弹窗</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222113331-985296239.png" alt></p>
<p>同时，为了证明除了e_magic和e_lfanew这两个属性，其他属性都是没用的，我们也可以把除了这两个属性之外的属性全部填充为00，再次尝试运行demo.exe。</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222119442-1699439644.png" alt></p>
<p>发现仍然可以正常运行</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222122974-512953698.png" alt></p>
<p>好，那么我们刚才填充为00的这些属性到底有啥用呢，为什么要留着他们呢？</p>
<p>我们把00000000到000000B0之间的数据拷贝下来粘贴进一个新文件，保存为dos.bin</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222130521-598472939.png" alt></p>
<p>然后我们用IDApro打开这个dos.bin文件。</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222135461-1768083568.png" alt></p>
<p>这一块代码实际上是在编译-连接的时候自动添加进来的一个程序，被称为DOS存根</p>
<p>读一下汇编，它的作用就是输出”This program cannot be run in DOS mode.”这个字符串，然后功能吗是4C01，即退出程序。</p>
<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><ol>
<li>可执行文件开始的两个字节是MZ</li>
<li>学会找到e_lfanew偏移位置</li>
<li>学会逐字节对应DOS头的每个属性</li>
</ol>
<h1 id="文件头及编程分析"><a href="#文件头及编程分析" class="headerlink" title="文件头及编程分析"></a>文件头及编程分析</h1><h2 id="文件头定义"><a href="#文件头定义" class="headerlink" title="文件头定义"></a>文件头定义</h2><p>通过前面介绍的DOS头（IMAGE_DOS_HEADER）中的e_lfanew属性，我们可以找到真正的PE头（IMAGE_NT_HEADERS），IMAGE_NT_HEADERS的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_NT_HEADERS64          IMAGE_NT_HEADERS;</span><br><span class="line"><span class="keyword">typedef</span> PIMAGE_NT_HEADERS64         PIMAGE_NT_HEADERS;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_NT_HEADERS32          IMAGE_NT_HEADERS;</span><br><span class="line"><span class="keyword">typedef</span> PIMAGE_NT_HEADERS32         PIMAGE_NT_HEADERS;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>我们发现这个HEADER加了个S，说明他不是单个头组成的，是由多个头组成的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS64</span> &#123;</span>    <span class="comment">// 64位版本</span></span><br><span class="line">  DWORD                   Signature;</span><br><span class="line">  IMAGE_FILE_HEADER       FileHeader;</span><br><span class="line">  IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span>     <span class="comment">// 32位版本</span></span><br><span class="line">  DWORD                   Signature;</span><br><span class="line">  IMAGE_FILE_HEADER       FileHeader;</span><br><span class="line">  IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>
<p>这里重点介绍32位的（32和64位的只有属性宽度等不同）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">  DWORD                   Signature;   <span class="comment">// PE标识符，即之前提到的PE00</span></span><br><span class="line">  IMAGE_FILE_HEADER       FileHeader;  <span class="comment">// 文件头</span></span><br><span class="line">  IMAGE_OPTIONAL_HEADER32 OptionalHeader;  <span class="comment">// 可选头</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>
<p>文件头结构体用于判断其是exe文件还是dll文件，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该结构体可以用于判断文件是exe文件还是dll文件 </span></span><br><span class="line"><span class="comment">// 14h 20d</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">   WORD Machine; 							<span class="comment">// 0x04 运行平台</span></span><br><span class="line">   WORD NumberOfSections; 					 <span class="comment">// 0x06 PE中节的数量，最大96个节 </span></span><br><span class="line">   DWORD TimeDateStamp; 					 <span class="comment">// 0x08 文件创建日期和时间，编译器创建此文件时的时间戳 </span></span><br><span class="line">   DWORD PointerToSymbolTable;				 <span class="comment">// 0x0C 指向符号表（用于调试）</span></span><br><span class="line">   DWORD NumberOfSymbols; 					 <span class="comment">// 0x10 符号表中符号个数（用于调试）</span></span><br><span class="line">   WORD SizeOfOptionalHeader; 				 <span class="comment">// 0x14 可选头IMAGE_OPTIONAL_HEADER结构体的长度 32位是E0 64位是F0</span></span><br><span class="line">   WORD Characteristics; 					<span class="comment">// 0x16 文件的属性 exe是010f dll是210e</span></span><br><span class="line">&#125;IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SIZEOF_FILE_HEADER 20</span></span><br></pre></td></tr></table></figure>
<p>重点关注<code>Machine，NumberOfSections，SizeOfOptionalHeader和Characteristics</code>。</p>
<p>IMAGE_FILE_HEADER.MACHINE的常用取值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lMAGE_FILE_MACHINE_1386         0x014c <span class="comment">// Intel 386</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lMAGE_FILE_MACHINE_IA64         0x0200 <span class="comment">// Intel 64</span></span></span><br></pre></td></tr></table></figure>
<p>IMAGE_FILE_HEADER.Characteristics的常用属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_RELOCS_STRIPPED			0x0001 <span class="comment">// Relocation info stripped from file.没有重定位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_EXECUTABLE_IMAGE 		0x0002 <span class="comment">// File is executable (i.e. no unresolved externel references).表示是可执行的</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_LINE_NUMS_STRIPPED 		0x0004 <span class="comment">// Line nunbers stripped from file.跳过行号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_LOCAL_SYMS_STRIPPED 		0x0008 <span class="comment">// Local symbols stripped from file跳过符号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_32BIT_MACHINE			0x0100 <span class="comment">// 32 bit word machine是32位机器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_SYSTEM 					0x1000 <span class="comment">// System File.是系统文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_FILE_DLL 						0x2000 <span class="comment">// File is a DLL.是DLL文件</span></span></span><br></pre></td></tr></table></figure>
<h2 id="16进制窗口对照"><a href="#16进制窗口对照" class="headerlink" title="16进制窗口对照"></a>16进制窗口对照</h2><p>用16进制编辑器打开之前的demo.exe</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222149398-14529939.png" alt></p>
<p>通过之前的分析我们知道真正的PE头是在00B0处开始的，我们找到相应的位置</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222155953-1432016152.png" alt></p>
<p>前面4个字节是signature标识符PE00，接下来分别是：</p>
<p>Machine，长度为2字节，值为01 4C，即Intel 386，为32位平台。</p>
<blockquote>
<p>0x014c为Intel 386，0x0200为Intel 64</p>
</blockquote>
<p>NumberOfSections，2字节，由于小端序的原因，值为00 03，也就是3个节（区段）。</p>
<p>TimeDateStamp，4字节，值为F8 22 DD 61，61DD22F8代表文件编译的时间，源代码编译完后生成的是obj文件，再经过连接才生成了exe文件，这个时间戳就是给obj文件使用的。</p>
<p>PointerToSymbolTable，NumberOfSymbols，都是4字节，值也都是00，用于调试，不用管。</p>
<p>SizeOfOptionalHeader，2字节，由于小端序，值为00 E0， 说明他是32位文件 。</p>
<blockquote>
<p>32位是E0，64位是F0</p>
</blockquote>
<p>Characteristics，2字节，由于小端序，值为 01 0F，说明他是exe文件。 </p>
<blockquote>
<p>exe是010f，dll是210e</p>
</blockquote>
<p>另外，010F = 1 + 2 + 4 + 8 + 0100，根据Characteristics的常用属性可以知道</p>
<ul>
<li>它没有重定位的数</li>
<li>它是一个可执行文件</li>
<li>没有行号</li>
<li>没有本地符号</li>
<li>在32位机器上运行</li>
</ul>
<h2 id="文件解析"><a href="#文件解析" class="headerlink" title="文件解析"></a>文件解析</h2><p>这里使用编程实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FILENAME <span class="string">L&quot;C:\\Users\\Misranduil\\Desktop\\demo.exe&quot;</span></span></span><br><span class="line"><span class="comment">//解析DOS头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintDosHdr</span><span class="params">(PIMAGE_DOS_HEADER pImgDosHdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;IMAGE_DOS_HEADER:\r\n&quot;</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	    typedef struct _IMAGE_DOS_HEADER &#123;</span></span><br><span class="line"><span class="comment">      WORD e_magic;</span></span><br><span class="line"><span class="comment">      WORD e_cblp;</span></span><br><span class="line"><span class="comment">      WORD e_cp;</span></span><br><span class="line"><span class="comment">      WORD e_crlc;</span></span><br><span class="line"><span class="comment">      WORD e_cparhdr;</span></span><br><span class="line"><span class="comment">      WORD e_minalloc;</span></span><br><span class="line"><span class="comment">      WORD e_maxalloc;</span></span><br><span class="line"><span class="comment">      WORD e_ss;</span></span><br><span class="line"><span class="comment">      WORD e_sp;</span></span><br><span class="line"><span class="comment">      WORD e_csum;</span></span><br><span class="line"><span class="comment">      WORD e_ip;</span></span><br><span class="line"><span class="comment">      WORD e_cs;</span></span><br><span class="line"><span class="comment">      WORD e_lfarlc;</span></span><br><span class="line"><span class="comment">      WORD e_ovno;</span></span><br><span class="line"><span class="comment">      WORD e_res[4];</span></span><br><span class="line"><span class="comment">      WORD e_oemid;</span></span><br><span class="line"><span class="comment">      WORD e_oeminfo;</span></span><br><span class="line"><span class="comment">      WORD e_res2[10];</span></span><br><span class="line"><span class="comment">      LONG e_lfanew;</span></span><br><span class="line"><span class="comment">    &#125; IMAGE_DOS_HEADER,*PIMAGE_DOS_HEADER;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">//逐个解析就好了，这里只解析e_magic 和 e_lfanew</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;e_magic:%04X(%c%c)\r\n&quot;</span>, pImgDosHdr -&gt; e_magic, *(<span class="type">char</span>*)pImgDosHdr, *((<span class="type">char</span>*)pImgDosHdr + <span class="number">1</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;e_res[4]:&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%02X &quot;</span>, pImgDosHdr -&gt; e_res[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;e_lfanew:%08X\r\n&quot;</span>, pImgDosHdr -&gt; e_lfanew);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析NT头</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintNtHdr</span><span class="params">(PIMAGE_NT_HEADERS pImgNtHdrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;IMAGE_NT_HEADERS:\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Signature:%08X(%s)\r\n&quot;</span>, pImgNtHdrs -&gt; Signature, pImgNtHdrs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 打开文件 </span></span><br><span class="line">	HANDLE hFile = <span class="built_in">CreateFile</span>(FILENAME, GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// 创建文件内核映射对象 </span></span><br><span class="line">	HANDLE hMap = <span class="built_in">CreateFileMapping</span>(hFile, <span class="literal">NULL</span>, PAGE_READONLY, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">// 将文件映射入内存 </span></span><br><span class="line">	LPVOID lpBase = <span class="built_in">MapViewOfFile</span>(hMap, FILE_MAP_READ, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER) lpBase;</span><br><span class="line">	PIMAGE_NT_HEADERS32 pImgNtHdr = (PIMAGE_NT_HEADERS) ((DWORD)lpBase + (DWORD)pImgDosHdr -&gt; e_lfanew); </span><br><span class="line">	<span class="built_in">PrintDosHdr</span>(pImgDosHdr);</span><br><span class="line">	<span class="built_in">PrintNtHdr</span>(pImgNtHdr);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 释放文件映射 </span></span><br><span class="line">	<span class="built_in">UnmapViewOfFile</span>(lpBase);</span><br><span class="line">	<span class="comment">// 光比文件内核映射对象 </span></span><br><span class="line">	<span class="built_in">CloseHandle</span>(hMap); </span><br><span class="line">	<span class="comment">// 关闭文件 </span></span><br><span class="line">	<span class="built_in">CloseHandle</span>(hFile);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入大概为（莫得Microsoft Visual Studio，直接网页截图了）</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222217399-1844150431.png" alt></p>
<h1 id="可选头"><a href="#可选头" class="headerlink" title="可选头"></a>可选头</h1><p>在第三节中我们了解到PE头是多个头的组合，其定义为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">  DWORD                   Signature;   <span class="comment">// PE标识符，即之前提到的PE00</span></span><br><span class="line">  IMAGE_FILE_HEADER       FileHeader;  <span class="comment">// 文件头</span></span><br><span class="line">  IMAGE_OPTIONAL_HEADER32 OptionalHeader;  <span class="comment">// 可选头</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure>
<p>我们已经介绍了文件头，这一节我们来介绍可选头。</p>
<p>可选头是IMAGE_OPTIONAL_HEADER，它是PE头部中重要的头部，虽然被称为可选头，但是并不是它说的可有可无，而是指该结构体中的部分数据在不同的文件中是不同的。</p>
<h2 id="可选头定义"><a href="#可选头定义" class="headerlink" title="可选头定义"></a>可选头定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 32位头的大小是e0h, 224d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Standard fields. 标准字段 </span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    WORD    Magic; <span class="comment">// 0x18 魔术字 107h = ROM Image 10Bh = EXE(32位) Image 20Bh = PE32+(64位) </span></span><br><span class="line">    BYTE    MajorLinkerVersion; <span class="comment">// 0x1A 连接器主版本号(对执行没有任何影响)</span></span><br><span class="line">    BYTE    MinorLinkerVersion; <span class="comment">// 0x1B 连接器次版本号(对执行没有任何影响)</span></span><br><span class="line">    DWORD   SizeOfCode; <span class="comment">// 0x1C 所有含代码的节的大小（按照文件对齐，判断某节是否含代码，使用节属性是否包含TNA</span></span><br><span class="line">    <span class="comment">// (GE_scu_cwr_coE属性判断，而不是通过IMAGE_sCN_CNT_EXECUTE)</span></span><br><span class="line">    DWORD   SizeOfInitializedData; <span class="comment">// 0x20 所有含有初始化数据的节的大小</span></span><br><span class="line">    DWORD   SizeOfUninitializedData; <span class="comment">// 0x24 所有含未初始化数据的节的大小(被定义为未初始化，不占用文件空间，加载入内存后为其分配空间)</span></span><br><span class="line">    DWORD   AddressOfEntryPoint; <span class="comment">// 0x28 程序执行入口RVA(距离PE加载后地址的距离，对于病毒和加密程序，都会修改该值，从而获得程序的控制权，对于DLL如果没有入口函数，那么是0，对于驱动该值是初始化的函数的地址)</span></span><br><span class="line">    DWORD   BaseOfCode; <span class="comment">// 0x2C 代码的节的起始RVA(一般情况下跟在PE头部的后面)</span></span><br><span class="line">    DWORD   BaseOfData; <span class="comment">// 0x30 数据的节的起始RVA </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// NT additional fields. NT系统增加的字段 </span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    DWORD   ImageBase; <span class="comment">// 0x34 程序的建议装载地址 （如果被占用了就不能装载在这个地方了）</span></span><br><span class="line">    DWORD   SectionAlignment; <span class="comment">// 0x38 内存中的节的对齐值 32位0x1000 64位0x2000</span></span><br><span class="line">    DWORD   FileAlignment; <span class="comment">// 0x3C 文件中的节的对齐值 0x1000或者0x200</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion; <span class="comment">// 0x40 操作系统主版本号</span></span><br><span class="line">    WORD    MinorOperatingSystemVersion; <span class="comment">// 0x42 操作系统次版本号</span></span><br><span class="line">    WORD    MajorImageVersion; <span class="comment">// 0x44 该PE的主版本号</span></span><br><span class="line">    WORD    MinorImageVersion; <span class="comment">// 0x46 该PE的次版本号</span></span><br><span class="line">    WORD    MajorSubsystemVersion; <span class="comment">// 0x48 所需子系统的主版本号</span></span><br><span class="line">    WORD    MinorSubsystemVersion; <span class="comment">// 0x4A 所需子系统的次版本号</span></span><br><span class="line">    DWORD   Win32VersionValue; <span class="comment">//0x4C 未使用,必须为0</span></span><br><span class="line">    DWORD   SizeOfImage; <span class="comment">// 0x50 内存中的整个PE文件映像大小(按照内存对齐)</span></span><br><span class="line">    DWORD   SizeOfHeaders; <span class="comment">// 0x54 所有头+节表的大小</span></span><br><span class="line">    DWORD   CheckSum; <span class="comment">// 0x58 校验和(一般exe文件为0，而dll和sys文件则必须是正确的值)</span></span><br><span class="line">    WORD    Subsystem; <span class="comment">// 0x5C 文件子系统</span></span><br><span class="line">    WORD    DllCharacteristics; <span class="comment">// 0x5E DLL文件特性</span></span><br><span class="line">    DWORD   SizeOfStackReserve; <span class="comment">// 0x60 初始化时保留的栈大小(默认1M）</span></span><br><span class="line">    DWORD   SizeOfStackCommit; <span class="comment">// 0x64 初始化时实际提交的钱大小(默认4k)</span></span><br><span class="line">    DWORD   SizeOfHeapReserve; <span class="comment">// 0x68 初始化时保留的堆大小(默认1M）</span></span><br><span class="line">    DWORD   SizeOfHeapCommit; <span class="comment">// 0x6C 初始化时实际提交的堆大小(默认4K)</span></span><br><span class="line">    DWORD   LoaderFlags; <span class="comment">// 0x70 加载标志一般为0</span></span><br><span class="line">    DWORD   NumberOfRvaAndSizes; <span class="comment">// 0x74 数据目录的数效量（就是下面那个数组的大小）</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; <span class="comment">// 0x78 数据目录数组</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>RVA是相对起始地址，后面会提到</p>
<p>建议装载地址：</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Users\Misranduil\Desktop\for_wp\typora-user-images\1657185138122.png" alt="1657185138122"></p>
<p>如图为一个虚拟地址内存，比如我们在低2G装载一个exe文件，而加载的dll文件A,B的起始地址重合了，那么就系统会自动给已经被占用的dll文件重新分配。</p>
<p>对齐：32位默认对齐值4K=4096=0x1000，64位默认8K。是内存分页的一个对齐值，大概意思就是比如：A班有50人，坐在一间教师里，B班只有两个人，但是也要坐在相同大的教室里。</p>
</blockquote>
<h2 id="在16进制编辑器中查看可选头"><a href="#在16进制编辑器中查看可选头" class="headerlink" title="在16进制编辑器中查看可选头"></a>在16进制编辑器中查看可选头</h2><p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222231479-258426171.png" alt></p>
<p>由于之前的知识，我们知道00B0开始是PE头，长度为20字节，于是我们可以知道可选头即为选中部分。</p>
<ul>
<li><p>Magic是0x010B，表示exe文件</p>
</li>
<li><p>要求最低的主版本号0x05，辅版本号0x0C</p>
</li>
<li><p>代码大小是0x00002000</p>
</li>
<li><p>包含的初始化数据大小是00004000</p>
</li>
<li><p>包含的未初始化数据大小是0</p>
</li>
<li><p>程序入口地址是00001000</p>
</li>
<li><p>代码起始地址是00001000</p>
</li>
<li><p>数据的起始地址是00001000</p>
</li>
<li><p>建议装载地址是00004000</p>
</li>
<li><p>……</p>
</li>
</ul>
<p>后面还有一堆就不列举了。</p>
<h1 id="节表解析与地址转换"><a href="#节表解析与地址转换" class="headerlink" title="节表解析与地址转换"></a>节表解析与地址转换</h1><p>在PE文件中经常会用到三种地址，分别是</p>
<ul>
<li>VA (Virtual Address): 虚拟地址</li>
<li>RVA (Relatvie Virtual Address)∶ 相对虚拟地址</li>
<li>FOA (File Offset Address): 文件偏移地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Section header format.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此处偏移是按照每个IMAGE_SECTION_HEADER开始的(大小为28h,40d)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SIZEOF_SHORT_NAME 8       <span class="comment">//（节的长度最长为8）</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> struct_IMAGE_SECTION_HEADER</span><br><span class="line">&#123;</span><br><span class="line">	BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">// 000h节名称</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		DWORD PhysicalAddress;</span><br><span class="line">		DWORD VirtualSize               <span class="comment">// 0008h 节区的尺寸 </span></span><br><span class="line">	&#125;Misc;</span><br><span class="line">	DWORD VirtualAddress;               <span class="comment">// 000ch 节区的起始RVA地址</span></span><br><span class="line">	DWORD SizeOfRawData;                <span class="comment">// 0x10 在文件中对齐后的尺寸 </span></span><br><span class="line">    DWORD PointerToRawData;             <span class="comment">// 0x14 该节在文件中的起始偏移</span></span><br><span class="line">    DWORD PointerToRelocations;         <span class="comment">// 0x18 在OBJ文件中使用 </span></span><br><span class="line">    DWORD PointerToLinenumbers;         <span class="comment">// 0x1C 行号表的位置(调试用)</span></span><br><span class="line">    WORD NumberOfRelocations;           <span class="comment">// 0x20 在OBJ文件中使用 </span></span><br><span class="line">    WORD NumberOfLinenumbers;           <span class="comment">// 0x24 行号表中行号的数量 </span></span><br><span class="line">    DWORD Characteristics;              <span class="comment">// 0x28 节的属性 </span></span><br><span class="line">&#125;IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER; </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SIZEOF_SECTION_HEADER </span></span><br></pre></td></tr></table></figure>
<h2 id="用LordPE解析节表"><a href="#用LordPE解析节表" class="headerlink" title="用LordPE解析节表"></a>用LordPE解析节表</h2><p>我们用LordPE载入之前写的demo.exe并打开节表</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222241715-1378380701.png" alt></p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222302027-1975320045.png" alt></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称（Name）</th>
<th>只是一个标识，可有可无，对数据没有影响，有些软件保护会把这个名称擦除、改名或者随机化</th>
</tr>
</thead>
<tbody>
<tr>
<td>在内存中的节区长度（VSize)</td>
<td>是没有对齐的,在结构体中是union里的VirtualSize</td>
</tr>
<tr>
<td>节区的起始RVA地址(VOffset)</td>
<td>由于 <img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222322204-2088468324.png" alt></td>
</tr>
</tbody>
</table>
</div>
<p>所以起始RVA分别是1000,2000,3000，是结构体里的VirtualAddress |<br>| 在文件中的尺寸（Rsize）       | 这个是对齐的，对应结构体中的SizeOfRawData                    |<br>| 在文件中的起始偏移（ROffset） | 由于 <img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222335110-1340023422.png" alt><br>所以起始文件偏移为200,400,600 |</p>
<p>再打开编辑区段中的标志</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222356635-788810149.png" alt></p>
<p>右下角就是结构体中的Characteristics，这个值的得出方法为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Section characteristics.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IMAGE_SCN_TYPE_REG 0x00000000 // Reserved.</span></span><br><span class="line"><span class="comment">// IMAGE_SCN_TYPE_DSECT 0x00000001 // Reserved.</span></span><br><span class="line"><span class="comment">// IMAGE_SCN_TYPE_NOLOAD 0x00000002 // Reserved.</span></span><br><span class="line"><span class="comment">// IMAGE_SCN_TYPE_GROUP 0x00000004 // Reserved.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_TYPE_NO_PAD 0x00000008 <span class="comment">// Reserved.</span></span></span><br><span class="line"><span class="comment">// IMAGE_SCN_TYPE_COPY 0x00000008 // Reserved.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCH_CNI_CODE 0x00000020 <span class="comment">// Section contains code.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN CNINITIALIZED_DATA 0x00000040 <span class="comment">// Seccion contains</span></span></span><br><span class="line">initialized data.</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IAGE_SCN_CNT_UNINITIALIZED_DATAun 0x00000080 <span class="comment">// Section contains</span></span></span><br><span class="line">initialized data.</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IHAGE SCN_INK_OTHER 0x00000100 <span class="comment">// Reserved.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE SCN_LNK_INEO 0x00000200 <span class="comment">// Section contains</span></span></span><br><span class="line">comzents or some other type of information.</span><br><span class="line"><span class="comment">// IMAGE SCN TYPE_OVER 0x00000400 // Reserved.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE SCN_LNK_REMOVE 0x00000800 <span class="comment">// Seccion contents will</span></span></span><br><span class="line">not become part of image.</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_LNK_COMDAT 0x00001000 <span class="comment">// Section contents comdat</span></span></span><br><span class="line"><span class="comment">// 0x00002000 // Reserved.</span></span><br><span class="line"><span class="comment">// IMAGE_SCN_HEM_PROTECTED - Obsolete 0x00004000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_NO_DEFER_SPEC_EXC 0x00004000 <span class="comment">// Reset speculative</span></span></span><br><span class="line">exceptions handling bits in the TLB entries <span class="keyword">for</span> chis section.</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE SCN GPREL 0x00008000 <span class="comment">// Section content can be</span></span></span><br><span class="line">accessed relative to GP</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_FARDATA 0x00008000</span></span><br><span class="line"><span class="comment">// IMAGE_SCN_MEM_SYSHEAP -Obsolete 0x00010000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_PURGEABLE 0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_16BIT 0x00020000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  IMAGE_SCN_MEM_LOCKER 0x00030000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_PRELOAD 0x00080000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE SCN ALIGN 1BYTES 0x00100000 <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE _SCN ALIGN 2BYTES 0x00200000 <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE SCN ALIGN 4BYTES 0x00300000 <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE SCN ALIGN SBYTES 0x00400000 <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN ALIGN 16BYTES 0x00500000 <span class="comment">// Default alignment if no</span></span></span><br><span class="line">others are specified.</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE SCN ALIGN 32BYTES 0x00600000 <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE SCN ALIGN 64BYTES 0x00700000 <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN ALIGN 128BYTES 0x00800000 <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE SCN ALIGN 256BYTES 0x00900000 <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE SCN ALIGN 512BYTES 0x00A00000 <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE SCN ALIGN 1024BYTES 0x00B00000 <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE SCN ALIGN 2048BYTES 0x00C00000 <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN ALIGN 4096BYTES 0x00D00000 <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_8192BYTES 0x00E00000 <span class="comment">//</span></span></span><br><span class="line"><span class="comment">//Unused 0x00F00000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_ALIGN_MASK 0x00F00000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_LNK_NRELOC_OVFL 0x01000000 <span class="comment">// Section contains</span></span></span><br><span class="line">extended relocations.</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_DISCARDABLE 0x02000000 <span class="comment">// Section can be discarded.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_NOT_CACHED 0x04000000 <span class="comment">// Section is not cachable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_NOT_PAGED 0x08000000 <span class="comment">// Section 1s not pageable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_SHARED 0x10000000 <span class="comment">// Section is shareable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_EXECUTE 0x20000000 <span class="comment">// Section is executable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_REXE 0x40000000 <span class="comment">// Section is readable.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SCN_MEM_WRITE 0x80000000 <span class="comment">//Section is writeable</span></span></span><br></pre></td></tr></table></figure>
<p>这些属性值相组合得出的就是最终的属性值，比如，当前值为</p>
<script type="math/tex; mode=display">0x60000020 = 0x200000000+0x400000000+0x00000020</script><p>而对应的属性分别为：可执行，可读，包含代码，正好和上图能对应上。</p>
<h2 id="用OD查看内存布局"><a href="#用OD查看内存布局" class="headerlink" title="用OD查看内存布局"></a>用OD查看内存布局</h2><p>用OD打开demo.exe，按M按钮打开内存布局</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222406526-1608636937.png" alt></p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222411013-1265526554.png" alt></p>
<p>发现PE头的装载地址是0x00400000，后面跟着3个节。同时发现虚拟地址VA = 相对虚拟地址RVA + 装载地址。</p>
<h2 id="字节转换"><a href="#字节转换" class="headerlink" title="字节转换"></a>字节转换</h2><p>比如我们要找字符串<code>Hello World!</code>在文件中的偏移地址FOA</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222416698-866073173.png" alt></p>
<p>我们发现该字符串的虚拟地址VA为0x00403006</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222421733-1613761173.png" alt></p>
<p>同时我们也知道每个节的VA，RVA，FOA。那么由此计算该字符串的FOA有两种方法。</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ol>
<li><p>计算内存中的虚拟地址VA - 装载地址 = 相对起始地址RVA ，即0x00403006 - 0x00400000 = 0x00003006</p>
</li>
<li><p>找到RVA对应的节，由于.data的RVA为0x00003000，长度为0x00001000，所以该字符串对应的节为.data</p>
</li>
<li><p>计算.data的RVA和FOA的差值，即0x00003000 - 0x00000600 = 0x00002800(注意是16进制计算)</p>
</li>
<li><p>用该字符串的RVA减去该差值得到其FOA，即0x00003006 - 0x00002800 = 0x00000806。</p>
</li>
</ol>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><ol>
<li>计算内存中的虚拟地址VA - 装载地址 = 相对起始地址RVA ，即0x00403006 - 0x00400000 = 0x00003006</li>
<li>找到RVA对应的节，由于.data的RVA为0x00003000，长度为0x00001000，所以该字符串对应的节为.data</li>
<li>计算RVA在.data节内的偏移，即0x00003006 - 0x00003000 = 0x00000006</li>
<li>节内偏移加上该节的起始FOA为该字符串的起始FOA，即0x00000006 + 0x00000800 = 0x00000806</li>
</ol>
<p>用16进制编辑器打开demo.exe，跳转到0x00000806地址。</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222430447-1392284532.png" alt></p>
<p>发现正是字符串hello world!的起始位置。</p>
<p>用LordPE中的位置计算器验证，在RVA处输入3006，点击执行</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222435477-32821756.png" alt></p>
<p>发现结果也完全正确。</p>
<blockquote>
<p>计算exe文件用VA来计算是可以的，但是如果是dll文件可能结果就不对了，因此一般用RVA来验算。</p>
</blockquote>
<p>文件解析和之前一样，把结构体中的每个属性输出一遍即可。</p>
<h1 id="添加节"><a href="#添加节" class="headerlink" title="添加节"></a>添加节</h1><p>添加节可以是一种软件保护措施，比如把可执行代码写入一个甚至两个节中打到保护的目的。</p>
<p>添加节的一般步骤</p>
<ol>
<li>增加节表项</li>
<li>修正文件的映像长度</li>
<li>修正一个节的数量</li>
<li>增加文件的节数据<br>即：IMAGE_OPTIONAL_HEADER.SizeOfImage;<br>IMAGE_FILE_HEADER.NumberOfSections;</li>
</ol>
<h2 id="用16进制编辑器增加节表项"><a href="#用16进制编辑器增加节表项" class="headerlink" title="用16进制编辑器增加节表项"></a>用16进制编辑器增加节表项</h2><p>用16进制编辑器打开demo.exe，找到节的位置（.text，.data，.rdata就是开始的地方）</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222445191-1961626872.png" alt></p>
<p>所以我们从0x220处开始添加节，长度为40字节。</p>
<p>根据上一节学到的节表构成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Section header format.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此处偏移是按照每个IMAGE_SECTION_HEADER开始的(大小为28h,40d)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SIZEOF_SHORT_NAME 8       <span class="comment">//（节的长度最长为8）</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> struct_IMAGE_SECTION_HEADER</span><br><span class="line">&#123;</span><br><span class="line">	BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="comment">// 000h节名称</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		DWORD PhysicalAddress;</span><br><span class="line">		DWORD VirtualSize               <span class="comment">// 0008h 节区的尺寸 </span></span><br><span class="line">	&#125;Misc;</span><br><span class="line">	DWORD VirtualAddress;               <span class="comment">// 000ch 节区的起始RVA地址</span></span><br><span class="line">	DWORD SizeOfRawData;                <span class="comment">// 0x10 在文件中对齐后的尺寸 </span></span><br><span class="line">    DWORD PointerToRawData;             <span class="comment">// 0x14 该节在文件中的起始偏移</span></span><br><span class="line">    DWORD PointerToRelocations;         <span class="comment">// 0x18 在OBJ文件中使用 </span></span><br><span class="line">    DWORD PointerToLinenumbers;         <span class="comment">// 0x1C 行号表的位置(调试用)</span></span><br><span class="line">    WORD NumberOfRelocations;           <span class="comment">// 0x20 在OBJ文件中使用 </span></span><br><span class="line">    WORD NumberOfLinenumbers;           <span class="comment">// 0x24 行号表中行号的数量 </span></span><br><span class="line">    DWORD Characteristics;              <span class="comment">// 0x28 节的属性 </span></span><br><span class="line">&#125;IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER; </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMAGE_SIZEOF_SECTION_HEADER </span></span><br></pre></td></tr></table></figure>
<p>我们可以依次添加我们想要的属性，先添加第一个属性：节名称吧，注意第一个字符是0x2E对应字符<code>.</code></p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222518680-1822873432.png" alt></p>
<p>第二个是节的大小，根据内存的对齐写0x1000即可，注意小端序。</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222552369-1787937377.png" alt></p>
<p>第三个是起始位置，根据上一个节.data的起始位置和大小分别为0x3000和0x13以及对齐为0x1000 <img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222605054-946414898.png" alt></p>
<p>我们知道添加节的起始位置为0x3000 + 0x1000 = 0x4000</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222619798-1546142385.png" alt></p>
<p>第四个是文件中的尺寸，根据对齐应该是0x200</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222625069-1966333700.png" alt></p>
<p>第五个是文件中的起始位置，由于上一个.data节的起始位置为0x800，对齐为0x200，所以添加节的文件起始位置为0x0A00（16进制)</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222642616-1679248749.png" alt></p>
<p>接下来的两个4字节和两个2字节是没用的，不填即可。</p>
<p>于是还剩最后一个Characteristic属性</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222650872-1732711818.png" alt></p>
<p>0xE0000060，即包含代码和初始化数据，可读，可写，可执行。</p>
<h2 id="修正文件的节数量和映像长度"><a href="#修正文件的节数量和映像长度" class="headerlink" title="修正文件的节数量和映像长度"></a>修正文件的节数量和映像长度</h2><p>先复习一下NT头，也就是文件头和可选头，要想修改节表数量和映像长度，我们只要找到文件头中的<code>NumberOfSections</code>和可选头中的`SizeOfImage即可</p>
<p>先改节数量</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222710687-1423726936.png" alt></p>
<p>然后是映像长度，可以用C32ASM中的查看-&gt;PE信息，在侧边栏中直接找到<code>SizeOfImage</code>属性并定位</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222717342-235857536.png" alt></p>
<p>也可以用长度来推，稍微有些麻烦，找到之后，原来的大小为0x4000，我们由于增加了0x1000，改成0x5000即可 <img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222729957-1636908876.png" alt></p>
<p>再在末尾插入512个00或者90（90对应的汇编是nop，同时文件对齐为0x200 = 512d）</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222746798-276577186.png" alt></p>
<p>保存后，文件仍可以正常运行</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222759749-1412709072.png" alt></p>
<h2 id="用PELord验证一下"><a href="#用PELord验证一下" class="headerlink" title="用PELord验证一下"></a>用PELord验证一下</h2><p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222812958-631666487.png" alt></p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222819164-464327663.png" alt></p>
<p>区段数目，镜像大小，以及新添加的.zym节，都显示了出来。</p>
<h1 id="导入表分析"><a href="#导入表分析" class="headerlink" title="导入表分析"></a>导入表分析</h1><blockquote>
<p>PE文件结构是Windows操作系统用来管理可执行文件的一种格式。通过前面的学习，我们已经对PE文件格式有了一定的掌握，比如对于一个可执行的EXE文件来说，在被操作系统装载时，会被装载到哪个虚拟地址，装载后会从哪个虚拟地址开始执行；PE文件会按照数据的属性进行分节，每个节装载入内存的什么位置，每个节具有哪些属性等。<br>PE文件不只是有头部，它还有一些PE体来作为可执行文件运行的支撑部分。</p>
</blockquote>
<h2 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h2><p>我们之前写过一个弹出对话框的程序</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222850493-136467163.png" alt></p>
<p>弹出对话框是因为我们用了一个API函数MessageBox，但其实这个API并不在我们写的程序中，</p>
<p>我们只是调用了它，而这个代码到底在哪里呢？</p>
<h2 id="用OD分析MessageBox的调用过程"><a href="#用OD分析MessageBox的调用过程" class="headerlink" title="用OD分析MessageBox的调用过程"></a>用OD分析MessageBox的调用过程</h2><p>用OD打开demo.exe</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222903652-1241266302.png" alt></p>
<p>一路F7到401012处，再按一次F7，发现跳转到了401024处</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222909325-1322672847.png" alt></p>
<p>再按一次回车，发现就是MessageBoxA实现的代码地址处</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222914407-1477811251.png" alt></p>
<p>再返回上一步</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222918497-880498438.png" alt></p>
<p>这个FF25是个操作码，后面的是一个小端序的内存0x00402008，我们查看该地址处存的是啥</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222922967-1552496977.png" alt></p>
<p>发现是0x76660C90，这个地址正好是MessageBoxA对应的地址</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222927549-599954699.png" alt></p>
<p>也就是说，当需要调用一个API的时候，会先call到一个jmp语句（调表），然后jmp语句中保存的地址就是真正要跳转的地址，而这个保存的地址是由编译器和连接器来写入的，而真正的地址是由windows系统通过装载器来完成的。</p>
<p>我们打开内存模块，由上图我们知道该API的地址开头为76，据此找到user32的大致的虚拟内存地址</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222933552-1516295769.png" alt></p>
<h2 id="导入表获取"><a href="#导入表获取" class="headerlink" title="导入表获取"></a>导入表获取</h2><p>导入表的定位：通过IMAGE_OPTIONAL_HEADER.DataDirectory的第二项获取。</p>
<p>我们用PElord打开demo.exe，并打开目录，第二项就是导入表（Import table)</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222940786-1253696504.png" alt></p>
<p>再点后面的三个点，查看导入表具体导入了哪些API</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222947115-999822391.png" alt></p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710222951243-1182242973.png" alt></p>
<p>发现正好有我们使用过的kernel32.dll中的ExitProcess函数和user32.dll中的MessageBoxA函数</p>
<h2 id="导入表具体字段分析"><a href="#导入表具体字段分析" class="headerlink" title="导入表具体字段分析"></a>导入表具体字段分析</h2><p>导入表定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA，指向的是一个INT(Import Name Table)，即表中所有API函数的RVA（这个RVA一般指向的是API函数的名字）</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 0 if not bound</span></span><br><span class="line">    								     <span class="comment">// -1 if bound, and real date\time stamp</span></span><br><span class="line">    									<span class="comment">// in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">										<span class="comment">// O.W. date/time of DLL bound to (Old BIND) </span></span><br><span class="line">    									<span class="comment">// 实际上可忽略 </span></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwards, 可忽略</span></span><br><span class="line">    DWORD   Name;                           <span class="comment">// 保存的是一个RVA,RVA指向的内容是一个dll名, 0指示结束, 不再继续遍历了</span></span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA，在内存中指向的是一个IAT(Import Address Table)表，保存的是所有函数的VA（地址），但是在文件中指向的是一个INT表，和OriginalFirstThunk相同。0也能指示结束, 不再继续遍历了</span></span><br><span class="line">&#125;IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>
<p><strong>注意：<code>FirstThunk</code>在内存中指向的是一个IAT(Import Address Table)表，保存的是所有函数的VA（地址），但是在文件中指向的是一个INT表，和OriginalFirstThunk相同，即在内存中会把这个表替换成真正函数的地址</strong></p>
<p>具体区别如下图：</p>
<p>文件中：</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710223003414-357251321.png" alt></p>
<p>可以发现<code>OriginalFirstThunk，FirstThunk</code>均指向的是INT，有可能是一个RVA，也有可能是一个数值</p>
<p>内存中：</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710223035054-216824835.png" alt></p>
<p>可以发现<code>FirstThunk</code>指向的是真正的函数入口地址。</p>
<p>由上图我们发现FirstThunk指向IMAGE_THUNK_DATA32结构体，有可能是一个RVA，有可能是一个数值，这是因为其构成是一联合体(union)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">		DWORD ForwarderString; <span class="comment">// PBYTE</span></span><br><span class="line">		DWORD Function; <span class="comment">// PDWORD</span></span><br><span class="line">		DWORD Ordinal;</span><br><span class="line">		DWORD AddressOfData; <span class="comment">// PIMAGE_IMPORT_BY_NAME</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个联合体(union) 中有4个字段，但是他所占的空间是其中最大的类型的空间(DWORD, 4字节)而不是4个字段之和（4 * 4 = 16）</p>
</blockquote>
<p>如果他的值的最高位是1的话，那么他的低16位是导入的序号</p>
<p>而如果他的值最高位不是1的话，那么这个值指向的值是导入函数的名称，这个名称在 _IMAGE_IMPORT_BY_NAME这个结构体里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    	WORD Hint;</span><br><span class="line">    	CHAR Name[<span class="number">1</span>];</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME,*PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>
<p>这里再介绍一下序号导入：</p>
<p>我们用PElord打开一个较复杂的exe文件，找到导入表</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710223056654-1683548690.png" alt></p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710223103433-142497023.png" alt></p>
<p>发现再Thunk值不是1的时候，后面的API名称一栏就是以字符串形式出现的API名称，但是如果最高位是8<strong>（在16进制下的0x8转化成2进制就是1000，也就是说其最高位是1）</strong>，后面的API名称就是序号。</p>
<h2 id="文件解析-1"><a href="#文件解析-1" class="headerlink" title="文件解析"></a>文件解析</h2><p>用C32ASM打开demo.exe，在查看-&gt;PE信息中找到IMAGE_DIRECTORY_ENTRY_IMPORT（导入表）</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710223109231-1947734248.png" alt></p>
<p>其RVA为0x2010，大小为0x3C也就是60，我们把它转化成FOA</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710223114523-1593190486.png" alt></p>
<p>发现其在文件中的地址FOA为0x610，我们跳转到该地址</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710223121182-1640415375.png" alt></p>
<p>前60个字节就是导入表，根据前面的导入表定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        DWORD   Characteristics;            </span><br><span class="line">        DWORD   OriginalFirstThunk; </span><br><span class="line">    &#125;DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;</span><br><span class="line">    DWORD   ForwarderChain;  </span><br><span class="line">    DWORD   Name;      </span><br><span class="line">    DWORD   FirstThunk;</span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>
<h2 id="4C-20-00-00"><a href="#4C-20-00-00" class="headerlink" title="4C 20 00 00"></a>4C 20 00 00</h2><p>即<code>OriginalFirstThunk</code>，是一个RVA值，指向的是一个INT(IMAGE_THUNK_DATA)，这个值转化成FOA是0x64C</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710223127841-2095804294.png" alt></p>
<p>由于INT中的值都是DWORD型也就是4字节，这个值是一个RVA，其值为0x205C，我们再把这个RVA再转化为FOA，得到文件中的地址为0x65C，这个位置正好是ExitProcess</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710223133876-406513098.png" alt></p>
<h2 id="6A-20-00-00"><a href="#6A-20-00-00" class="headerlink" title="6A 20 00 00"></a>6A 20 00 00</h2><p>中间的<code>TimeDateStamp</code>和<code>ForwarderChain</code>都是0，直接跳过，接下来是Name，0x206A转化出来的FOA是0x66A</p>
<p>是kernel32.dll</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710223142555-967930540.png" alt></p>
<h2 id="00-20-00-00"><a href="#00-20-00-00" class="headerlink" title="00 20 00 00"></a>00 20 00 00</h2><p>即FitstThunk，在文件中指向的也是是IMAGE_THUNK_DATA，0x2000转化出来是0x600</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710223157663-1154106448.png" alt></p>
<p>这个值也是一个RVA，其值为0x205C，发现和前面的4C 20 00 00一样，都是ExitProcess函数</p>
<h2 id="86-20-00-00"><a href="#86-20-00-00" class="headerlink" title="86 20 00 00"></a>86 20 00 00</h2><p>0x2086转化成FOA是0x686</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710223203150-1351334891.png" alt></p>
<p>是user32.dll</p>
<p>剩下的导入表全是00。</p>
<h2 id="内存解析"><a href="#内存解析" class="headerlink" title="内存解析"></a>内存解析</h2><p>用OD打开demo.exe，导入表的RVA为0x2010，加上装载地址，把RVA转化成VA也就是0x402010</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710223209793-994679437.png" alt></p>
<p> 前面是一样的，我们直接看00 20 00 00，也就是<code>FirstThunk</code>的位置，转化为VA为0x402000</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710223214537-744649929.png" alt></p>
<p>我们发现这个值已经不是0x205C了，而是0x76394100，直接跳转到该地址处</p>
<p><img src="/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1688456-20220710223220395-931882810.png" alt></p>
<p>发现就是ExitUserProcess这个函数在内存中的地址而不是一个字符串了，这就是导入表在文件和在内存中的区别。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://example.com">EPs1l0h</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://example.com/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://example.com/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://example.com" target="_blank">EPs1l0h's Castle</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover1.jpg?raw=true" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/02/idapro%E5%BF%AB%E6%8D%B7%E9%94%AE/"><img class="prev-cover" src="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover6.jpg?raw=true" onerror="onerror=null;src='/img/404.gif'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">idapro快捷键</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/08/DSCTF2022%E5%A4%8D%E7%8E%B0/"><img class="next-cover" src="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover3.jpg?raw=true" onerror="onerror=null;src='/img/404.gif'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">DSCTF-2022-Ffunction</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">EPs1l0h</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/EPs1l0h"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Spears shall be shaken! Shields shall be splintered! A sword day! A red day! Ere the sun rises!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E4%B8%80%E6%AC%A1PE%E7%BC%96%E8%BE%91%E5%AE%9E%E7%8E%B0%E5%BC%B9%E7%AA%97%E5%BC%80%E5%A7%8B"><span class="toc-number">1.</span> <span class="toc-text">从一次PE编辑实现弹窗开始</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%8C%BA%E6%AE%B5"><span class="toc-number">1.1.</span> <span class="toc-text">添加区段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A816%E8%BF%9B%E5%88%B6%E7%BC%96%E8%BE%91%E5%99%A8%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">用16进制编辑器修改文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">PE文件结构概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%A0%97%E5%AD%90%EF%BC%88%E7%94%A8RadASM%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%A8%8B%E5%BA%8F%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">一个栗子（用RadASM编写一个简单程序）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8WinHex%E4%B8%AD%E5%AF%B9%E6%AF%94%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%9C%A8%E6%96%87%E4%BB%B6%E5%92%8C%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%B7%AE%E8%B7%9D"><span class="toc-number">2.2.</span> <span class="toc-text">在WinHex中对比可执行文件在文件和内存中的差距</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8PEView%E6%9F%A5%E7%9C%8B%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">用PEView查看可执行文件的结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DOS%E5%A4%B4"><span class="toc-number">3.</span> <span class="toc-text">DOS头</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E4%B8%BAPE%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">判断一个文件是否为PE文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E4%B8%AA%E7%A8%8B%E5%BA%8F%E8%AE%A1%E7%AE%97DOS-HEADER%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.2.</span> <span class="toc-text">写个程序计算DOS_HEADER大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%AE%9E%E9%AA%8C"><span class="toc-number">3.3.</span> <span class="toc-text">一个简单实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E8%8A%82"><span class="toc-number">3.4.</span> <span class="toc-text">小节</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%B4%E5%8F%8A%E7%BC%96%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">文件头及编程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%B4%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.</span> <span class="toc-text">文件头定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E8%BF%9B%E5%88%B6%E7%AA%97%E5%8F%A3%E5%AF%B9%E7%85%A7"><span class="toc-number">4.2.</span> <span class="toc-text">16进制窗口对照</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90"><span class="toc-number">4.3.</span> <span class="toc-text">文件解析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%A4%B4"><span class="toc-number">5.</span> <span class="toc-text">可选头</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E5%A4%B4%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.</span> <span class="toc-text">可选头定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A816%E8%BF%9B%E5%88%B6%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%AD%E6%9F%A5%E7%9C%8B%E5%8F%AF%E9%80%89%E5%A4%B4"><span class="toc-number">5.2.</span> <span class="toc-text">在16进制编辑器中查看可选头</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8A%82%E8%A1%A8%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.</span> <span class="toc-text">节表解析与地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8LordPE%E8%A7%A3%E6%9E%90%E8%8A%82%E8%A1%A8"><span class="toc-number">6.1.</span> <span class="toc-text">用LordPE解析节表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8OD%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">6.2.</span> <span class="toc-text">用OD查看内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.3.</span> <span class="toc-text">字节转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-number">6.4.</span> <span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-number">6.5.</span> <span class="toc-text">方法二</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%8A%82"><span class="toc-number">7.</span> <span class="toc-text">添加节</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A816%E8%BF%9B%E5%88%B6%E7%BC%96%E8%BE%91%E5%99%A8%E5%A2%9E%E5%8A%A0%E8%8A%82%E8%A1%A8%E9%A1%B9"><span class="toc-number">7.1.</span> <span class="toc-text">用16进制编辑器增加节表项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%AD%A3%E6%96%87%E4%BB%B6%E7%9A%84%E8%8A%82%E6%95%B0%E9%87%8F%E5%92%8C%E6%98%A0%E5%83%8F%E9%95%BF%E5%BA%A6"><span class="toc-number">7.2.</span> <span class="toc-text">修正文件的节数量和映像长度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8PELord%E9%AA%8C%E8%AF%81%E4%B8%80%E4%B8%8B"><span class="toc-number">7.3.</span> <span class="toc-text">用PELord验证一下</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E8%A1%A8%E5%88%86%E6%9E%90"><span class="toc-number">8.</span> <span class="toc-text">导入表分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">8.1.</span> <span class="toc-text">一个问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8OD%E5%88%86%E6%9E%90MessageBox%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">8.2.</span> <span class="toc-text">用OD分析MessageBox的调用过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E8%A1%A8%E8%8E%B7%E5%8F%96"><span class="toc-number">8.3.</span> <span class="toc-text">导入表获取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E8%A1%A8%E5%85%B7%E4%BD%93%E5%AD%97%E6%AE%B5%E5%88%86%E6%9E%90"><span class="toc-number">8.4.</span> <span class="toc-text">导入表具体字段分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90-1"><span class="toc-number">8.5.</span> <span class="toc-text">文件解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4C-20-00-00"><span class="toc-number">8.6.</span> <span class="toc-text">4C 20 00 00</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6A-20-00-00"><span class="toc-number">8.7.</span> <span class="toc-text">6A 20 00 00</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#00-20-00-00"><span class="toc-number">8.8.</span> <span class="toc-text">00 20 00 00</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#86-20-00-00"><span class="toc-number">8.9.</span> <span class="toc-text">86 20 00 00</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90"><span class="toc-number">8.10.</span> <span class="toc-text">内存解析</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/05/27/%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F-2024-re/" title="上海大学生-2024-re"><img src="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover2.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.gif'" alt="上海大学生-2024-re"/></a><div class="content"><a class="title" href="/2024/05/27/%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F-2024-re/" title="上海大学生-2024-re">上海大学生-2024-re</a><time datetime="2024-05-27T14:35:03.000Z" title="发表于 2024-05-27 22:35:03">2024-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/27/CISCN-2024-re/" title="CISCN-2024-re"><img src="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover2.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.gif'" alt="CISCN-2024-re"/></a><div class="content"><a class="title" href="/2024/05/27/CISCN-2024-re/" title="CISCN-2024-re">CISCN-2024-re</a><time datetime="2024-05-27T14:34:51.000Z" title="发表于 2024-05-27 22:34:51">2024-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/27/%E4%BA%AC%E9%BA%9FCTF-2024-re-wp/" title="京麟CTF-2024-re-wp"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.gif'" alt="京麟CTF-2024-re-wp"/></a><div class="content"><a class="title" href="/2024/05/27/%E4%BA%AC%E9%BA%9FCTF-2024-re-wp/" title="京麟CTF-2024-re-wp">京麟CTF-2024-re-wp</a><time datetime="2024-05-27T13:37:23.000Z" title="发表于 2024-05-27 21:37:23">2024-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/25/%E9%93%81%E4%B8%892024-re/" title="铁三2024-re"><img src="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover2.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.gif'" alt="铁三2024-re"/></a><div class="content"><a class="title" href="/2024/05/25/%E9%93%81%E4%B8%892024-re/" title="铁三2024-re">铁三2024-re</a><time datetime="2024-05-25T03:42:12.000Z" title="发表于 2024-05-25 11:42:12">2024-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/18/%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%88%9D%E6%8E%A2/" title="路由器漏洞挖掘初探"><img src="https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover1.jpg?raw=true" onerror="this.onerror=null;this.src='/img/404.gif'" alt="路由器漏洞挖掘初探"/></a><div class="content"><a class="title" href="/2024/04/18/%E8%B7%AF%E7%94%B1%E5%99%A8%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%88%9D%E6%8E%A2/" title="路由器漏洞挖掘初探">路由器漏洞挖掘初探</a><time datetime="2024-04-18T08:59:23.000Z" title="发表于 2024-04-18 16:59:23">2024-04-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://github.com/EPs1l0h/EPs1l0h.github.io/blob/main/medias/cover/cover1.jpg?raw=true')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By EPs1l0h</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://example.com/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'
    this.page.identifier = '/2022/08/04/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/'
    this.page.title = 'PE文件格式学习笔记'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }

  document.getElementById('darkmode').addEventListener('click', () => {
    setTimeout(() => window.disqusReset(), 200)
  })
}

if ('Disqus' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><div class="aplayer no-destroy" data-id="2981528901" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>